{"meta":{"title":"Edsion's Blog","subtitle":"","description":"","author":"Edsion Shen","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2020-05-25T05:40:33.763Z","updated":"2020-05-25T05:40:33.763Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-05-25T05:26:43.868Z","updated":"2020-05-25T05:26:43.868Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-05-25T05:27:03.044Z","updated":"2020-05-25T05:27:03.044Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"NMAP的使用","slug":"Nmap使用","date":"2020-06-27T06:53:22.000Z","updated":"2020-06-27T06:53:43.929Z","comments":true,"path":"2020/06/27/Nmap使用/","link":"","permalink":"http://yoursite.com/2020/06/27/Nmap%E4%BD%BF%E7%94%A8/","excerpt":"","text":"namp端口状态 123456Open(开放的): 应用程序正在这个端口上监听连接。losed(关闭的): 端口对探测做出了响应，但是现在没有应用程序在监听这个端口。Filtered(过滤的): 端口没有对探测做出响应。同时告诉我们探针可能被一些过滤器（防火墙）终止了。Unfiltered(未被过滤的):端口对探测做出了响应，但是Nmap无法确定它们是关闭还是开放。Open/Filtered: 端口被过滤或者是开放的，Nmap无法做出判断。Closed/Filtered: 端口被过滤或者是关闭的，Nmap无法做出判断。 TCP标志位 123456SYN(synchronous建立联机)ACK(acknowledgement 确认)PSH(push传送)FIN(finish结束)RST(reset重置)URG(urgent紧急) nmap常用命令 轻量级扫描： 1234567nmap -sP 192.168.0.0/24 判断哪些主机存活nmap -sT 192.168.0.3 开放了哪些端口nmap -sS 192.168.0.127 开放了哪些端口（隐蔽扫描）nmap -sU 192.168.0.127 开放了哪些端口（UDP）nmap -sS -O 192.168.0.127 操作系统识别nmap -sT -p 80 -oG – 192.168.1.* | grep open列出开放了指定端口的主机列表nmap -sV -p 80 thief.one 列出服务器类型(列出操作系统，开发端口，服务器类型,网站脚本类型等) 批量扫描： 123nmap -sT -sV -O -P0 --open -n -oN result.txt -p80-89,8080-8099,8000-8009,7001-7009,9000-9099,21,443,873,2601,2604,3128,4440,6082,6379,8888,3389,9200,11211,27017,28017,389,8443,4848,8649,995,9440,9871,2222,2082,3311,18100,9956,1433,3306,1900,49705,50030,7778,5432,7080,5900,50070,5000,5560,10000 -iL ip.txtnmap -sT -sV -p80-89,8080-8099,8000-8009,7001-7009,9000-9099,21,443,873,2601,2604,3128,4440,6082,6379,8888,3389,9200,11211,27017,28017,389,8443,4848,8649,995,9440,9871,2222,2082,3311,18100,9956,1433,3306,1900,49705,50030,7778,5432,7080,5900,50070,5000,5560,10000 --open --max-hostgroup 10 --max-parallelism 10 --max-rtt-timeout 1000ms --host-timeout 800s --max-scan-delay 2000ms -iL ~/Desktop/ip.txt -oN ~/Desktop/result/result.txt nmap参数 1234567891011121314151617181920212223242526272829303132333435nmap [Scan Type(s)] [Options] &#123;target specification&#125;scan type(s) 用于指定扫描类型options 用于指定选项target specification 用于指定扫描目标-s 指定扫描类型如下：-sP (ping扫描) *存活主机探测-sS (TCP SYN扫描 隐身扫描) *默认扫描方式，使用频率最高的半开放扫描-sT (tcp 扫描) *TCP connect()默认的扫描方式，完成三次握手-sU （UDP 扫描）用来探测目的的UDP端口，不需要发送任何的SYN包，发送UDP数据包到目的主机等待响应-sA （ACK扫描） *三次握手 用于探测出防火墙过滤端口 实际渗透中没多大用-sV （版本探测）-A 综合扫描（系统探测，版本探测，路由追踪以及一些常用脚本的扫描）-O （启用操作系统检测）-v详细选项说明-P0 [指定端口] (无ping扫描)-PU [指定端口] (udp ping扫描)-PS [指定端口] (TCP SYN ping 扫描)-PA [指定端口] (tcp ack ping扫描)-PI 使用真正的pingICMP echo请求来扫描目标主机是否正在运行-iL 指定扫描主机列表-iR 随机选择目标–exclude 排除扫描目标–excludefile 排除文件中目标列表-n (不用域名解析)-R (为所有目标解析域名)-T 时间优化（每隔多久发一次包 ） -T5 最快 -T0 最慢（5适合局域网）-F 快速扫描-e 指定网络接口-M 设置tcp扫描线程-iL 文件 指定一个文本内的所有主机nmap的输出：oN，oX，oS，oG（结果为一般模式。XML，kiddi3，grepable格式）nmap输出 ip：port 格式：nmap -vv -p 80 192.168.1.0/24 | grep “Discovered open port” | awk &#123;‘print $6”:”$4’&#125; | awk -F/ &#123;‘print $1’&#125; &gt; output.txt","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"NMAP","slug":"NMAP","permalink":"http://yoursite.com/tags/NMAP/"}]},{"title":"NSE编写","slug":"NSE编写","date":"2020-06-27T06:52:11.000Z","updated":"2020-06-27T06:53:26.030Z","comments":true,"path":"2020/06/27/NSE编写/","link":"","permalink":"http://yoursite.com/2020/06/27/NSE%E7%BC%96%E5%86%99/","excerpt":"","text":"NSE简介 Nmap 一款标志性的跨平台扫描器。它的原意为Network Mapper（网络映射器），具有相当强大的扫描功能。Nmap还可根据NSE (Nmap scripting Engine)的脚本进行大量渗透工作，这种脚本是基于Lua编程语言。正是NSE，使得Nmap不再普通。 Nmap的目录结构 Linux Windows 主要关注两个目录： neslib存放着各种库文件 script存放着NSE脚本 nmap脚本和库文件手册：https://nmap.org/nsedoc/ NSE中的库文件 NSE中的库文件实现了代码的分离和重构，有助于脚本的开发，其存放在nselib文件夹中。 库文件的编写 创建一个库文件保存为demo.lua，用于对于传入的参数 返回 这个端口 是开启的。 123function Test( port ) return string.format(&quot;The port &#39;%s&#39; is open&quot;,port)end 在脚本文件中引入这个库文件，引入库文件的格式一般为 local 库文件名 = require “库文件名” 业界人士称，在lua中，如果是一些经常用到的全局函数，可以申明为local局部变量，这样做可以提升效率。 在脚本中使用此库文件中的函数。 123456789101112local shortport &#x3D; require &quot;shortport&quot;local demo &#x3D; require &quot;demo&quot;description &#x3D; [[neslib demo test]]categories &#x3D; &#123;&quot;default&quot;&#125;portrule &#x3D; function(host,port) return port.protocol &#x3D;&#x3D; &quot;tcp&quot; and port.number &#x3D;&#x3D; 30081 and port.state &#x3D;&#x3D;&quot;open&quot;endaction &#x3D; function(host, port) return Test(port.number)end NSE编写规则 NSE脚本编写流程 大致分为四步： 导入脚本所需库 脚本描述信息及分类 rule类型：脚本的触发规则 action：脚本具体执行内容，rule触发规则为真时执行action定义的函数 Rule四种类型 Rule：用于描述脚本的触发规则，返回值只有true和false两种。返回值决定了后面action对应的函数是否执行，注意：true(执行),flase(不执行)。它有四种类型分别是 prerule()：不接收参数，脚本只运行一次，在主机发现之前，发生在预扫描阶段。返回的值永远为真。 hostrule(host)：设定参数为目标的ip地址或主机名，nmap完成了主机发现之后再运行脚本。 portrule(host,port)：设定参数需要主机以及端口。在端口扫描时，每个端口运行一次，处于open，open|filtered，或者unfiltered状态的所有端口。 postrule()：不接收参数，nmap完成所有主机已经被扫描后，在脚本的后扫描阶段。返回的值永远为真。 举个例子： 在扫描之前触发脚本，打印I Love China. 12345678910111213description = [[test]]author = \"Edsion\"license = \"Same as Nmap‐‐See http://nmap.org/book/man‐legal.html\"categories = &#123;\"default\",\"safe\"&#125;prerule = function(host,port)return trueendaction = function(host, port)return \"I Love China.\"end 调试模式 在测试阶段我们难免会出现错误,那假设我们出现了错误我们应该如何解决呢。这时我们需要借助Nmap的调试模式进行调试，只需要加上-d选项即可进入调试模式，那一般选择-d 3，3代表的是等级，等级越高，越详细。 nmap API nmap中API的核心功能就是向脚本提供主机和端口的信息。 两个lua table类型的参数：host table 、 port table host table类型 host.os 操作系统信息 host.ip tagret(目标主机)对应的ip,例如下面的127.0.0.1 host.name tagert在命令行对应的名字，例如下面的zzcms.im host.targetname 同上host.name，我个人是这样认为的 host.directly_connected 判断目标主机是否与本机在同一个子网 host.mac_addr mac地址 （必须是同一子网的设备这个命令才有效） port table类型 port.number 端口号 port.protocol 协议 port.service 服务 http或https port.version 版本信息 port.state 端口状态 http库参数扩展 http 库 get() 发起get请求，请求结果以一个table的形式返回 host 要请求的主机 path 要检索的路径 options 可选，允许调用者控制socket,请求头的table port 要检索的端口 post() 发起post请求，请求结果以一个table的形式返回 ignored 向后兼用，一般填写nil，忽略即可 postdata post数据，字符串或者table格式 host 要请求的主机 path 要检索的路径 options 可选，允许调用者控制socket,请求头,超时时间的table port 要检索的端口 NSE脚本分类 脚本类别 描述 auth 与用户认证相关的NSE脚本 broadcast 在局域网内探查更多服务开启状况，如dhcp/dns/sqlserver等服务 brute 暴力破解 default 默认，执行脚本（-A或者-sC） discovery 与主机和服务发现相关的脚本 dos 与拒绝服务攻击有关的脚本 exploit 利用已知的漏洞入侵系统 external 利用第三方的数据库或资源，例如进行whois解析 fuzzer 模糊测试的脚本，发送异常的包到目标机，探测出潜在漏洞 intrusive 入侵性的脚本，此类脚本可能引发对方的IDS/IPS的记录或屏蔽 malware 探测目标机是否感染了病毒、开启了后门等信息 safe 此类与intrusive相反，属于安全性脚本 vuln 负责检查目标机是否有常见的漏洞（Vulnerability），如是否有MS08_067 version 负责增强服务与版本扫描（Version Detection）功能的脚本 NSE脚本使用 123456789101112131415161718192021直接加脚本名称nmap --script http-title &lt;target&gt;nmap --script http-title，http-methods &lt;target&gt;类别nmap --script exploit &lt;target&gt;您也可以用逗号分隔它们来运行多个类别：nmap --script discovery,intrusive &lt;target&gt;路径或文件名（文件夹）nmap --script /path/to/script.nse &lt;target&gt;nmap --script /path/to/script.nse,/another/path/script2.nse &lt;target&gt;表达式nmap -sV --script \"not exploit\" &lt;target&gt;nmap --script \"not（intrusive or dos or exploit）\" -sV &lt;target&gt;通配符nmap --script \"snmp- *\" &lt;target&gt;为脚本提供参数 --script-args=x=x,y=y","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"NMAP","slug":"NMAP","permalink":"http://yoursite.com/tags/NMAP/"}]},{"title":"绕过CDN寻找真实IP","slug":"绕过CDN","date":"2020-06-23T04:17:11.000Z","updated":"2020-06-23T04:28:02.784Z","comments":true,"path":"2020/06/23/绕过CDN/","link":"","permalink":"http://yoursite.com/2020/06/23/%E7%BB%95%E8%BF%87CDN/","excerpt":"","text":"目前很多站点出于用户体验和安全的角度，使用CDN加速，将域名解析到CDN，这时候就需要绕过CDN来查找真实IP。 一、DNS历史解析记录 查询域名的历史解析记录，找网站使用CDN前的解析记录，从而获取真实ip，相关查询的网站有： 123456iphistory：https://viewdns.info/iphistory/DNS查询：（https://dnsdb.io/zh-cn/）微步在线：（https://x.threatbook.cn/）域名查询：（https://site.ip138.com/）DNS历史查询：（https://securitytrails.com/）Netcraft：https://sitereport.netcraft.com/?url=github.com 二、子域名 很多时候，一些重要的站点会做CDN，而一些子域名站点并没有加入CDN，而且跟主站在同一个C段内，这时候，就可以通过查找子域名来查找网站的真实IP。 常用的子域名查找方法和工具： 搜索引擎查询：如Google、baidu、Bing等传统搜索引擎，site:baidu.com inurl:baidu.com，搜target.com|公司名字。 在线查询网站： 12345http:&#x2F;&#x2F;tool.chinaz.com&#x2F;subdomain&#x2F;http:&#x2F;&#x2F;i.links.cn&#x2F;subdomain&#x2F; http:&#x2F;&#x2F;subdomain.chaxun.la&#x2F;http:&#x2F;&#x2F;searchdns.netcraft.com&#x2F;https:&#x2F;&#x2F;www.virustotal.com&#x2F; 子域名爆破工具 1234Layer子域名挖掘机wydomain：https:&#x2F;&#x2F;github.com&#x2F;ring04h&#x2F;wydomain subDomainsBrute:https:&#x2F;&#x2F;github.com&#x2F;lijiejie&#x2F;Sublist3r:https:&#x2F;&#x2F;github.com&#x2F;aboul3la&#x2F;Sublist3r 三、网站邮件头信息 比如：邮箱注册，邮箱找回密码、RSS邮件订阅等功能场景，通过网站给自己发送邮件，从而让目标主动暴露他们的真实的IP，查看邮件头信息，获取到网站的真实IP。 四、网络空间安全引擎搜索 通过关键字或网站域名，就可以找出被收录的IP，很多时候获取到的就是网站的真实IP。 123钟馗之眼：https:&#x2F;&#x2F;www.zoomeye.orgShodan：https:&#x2F;&#x2F;www.shodan.ioFofa：https:&#x2F;&#x2F;fofa.so 五、利用SSL证书 证书颁发机构(CA)必须将他们发布的每个SSL/TLS证书发布到公共日志中，SSL/TLS证书通常包含域名、子域名和电子邮件地址。因此SSL/TLS证书成为了攻击者的切入点。 SSL证书搜索引擎： 1https:&#x2F;&#x2F;censys.io&#x2F;ipv4?q&#x3D;github.com 六、国外主机解析域名 大部分 CDN 厂商因为各种原因只做了国内的线路，而针对国外的线路可能几乎没有，此时我们使用国外的DNS查询，很可能获取到真实IP。 国外多PING测试工具： 1234https:&#x2F;&#x2F;asm.ca.com&#x2F;zh_cn&#x2F;ping.phphttp:&#x2F;&#x2F;host-tracker.com&#x2F;http:&#x2F;&#x2F;www.webpagetest.org&#x2F;https:&#x2F;&#x2F;dnscheck.pingdom.com&#x2F; 七、全网扫描 通过Zmap、masscan等工具对整个互联网发起扫描，针对扫描结果进行关键字查找，获取网站真实IP。 ZMap号称是最快的互联网扫描工具，能够在45分钟扫遍全网。 1https:&#x2F;&#x2F;github.com&#x2F;zmap&#x2F;zmap Masscan号称是最快的互联网端口扫描器，最快可以在六分钟内扫遍互联网。 1https:&#x2F;&#x2F;github.com&#x2F;robertdavidgraham&#x2F;masscan 八、配置不当导致绕过 在配置CDN的时候，需要指定域名、端口等信息，有时候小小的配置细节就容易导致CDN防护被绕过。 案例1：为了方便用户访问，我们常常将www.test.com 和 test.com 解析到同一个站点，而CDN只配置了www.test.com，通过访问test.com，就可以绕过 CDN 了。 案例2：站点同时支持http和https访问，CDN只配置 https协议，那么这时访问http就可以轻易绕过。","categories":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/categories/%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"CDN","slug":"CDN","permalink":"http://yoursite.com/tags/CDN/"}]},{"title":"SqlMap代理池","slug":"代理池","date":"2020-06-22T07:16:21.000Z","updated":"2020-06-22T07:23:05.708Z","comments":true,"path":"2020/06/22/代理池/","link":"","permalink":"http://yoursite.com/2020/06/22/%E4%BB%A3%E7%90%86%E6%B1%A0/","excerpt":"","text":"获取代理池 获取代理池使用了GIthub上的项目：https://github.com/jhao104/proxy_pool ，并利用REDIS存储获取到的代理地址 启动项目 在cli目录下通过ProxyPool.py启动 12345# 首先启动调度程序&gt;&gt;&gt;python proxyPool.py schedule# 然后启动webApi服务&gt;&gt;&gt;python proxyPool.py webserver Api 启动过几分钟后就能看到抓取到的代理IP，可以直接到数据库中查看，也可以通过api访问http://127.0.0.1:5010 查看。 api method Description arg / GET api介绍 None /get GET 随机获取一个代理 None /get_all GET 获取所有代理 None /get_status GET 查看代理数量 None /delete GET 删除代理 proxy=host:ip 保存代理 自己编写了个小脚本将ProxyPool.py获取到的代理保存在ips.txt中 get_proxy.py： 1234567891011121314151617import requestsdef get_proxy(): return requests.get(&quot;http:&#x2F;&#x2F;127.0.0.1:5010&#x2F;get_all&#x2F;&quot;).json()def delete_proxy(proxy): requests.get(&quot;http:&#x2F;&#x2F;127.0.0.1:5010&#x2F;delete&#x2F;?proxy&#x3D;&#123;&#125;&quot;.format(proxy))res &#x3D; requests.get(&quot;http:&#x2F;&#x2F;127.0.0.1:5010&#x2F;get_status&quot;).json()count &#x3D; res.get(&quot;useful_proxy&quot;)print(&quot;目前代理池中共计：%s个代理.&quot; % count)f &#x3D; open(&quot;ips.txt&quot;, &quot;w&quot;)for i in range(count): b &#x3D; get_proxy()[i][&quot;proxy&quot;]f.write(b + &quot;\\n&quot;)f.close() 本地代理转发 借用前人的成果，实现的效果是启用本地127.0.0.1:9999服务，将ips.txt内的代理转发给本地客户端 ips.py： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#!/usr/bin/env python# -*- coding: utf-8 -*-import socketfrom socket import errorimport threadingimport randomimport timelocaltime = time.asctime(time.localtime(time.time()))class ProxyServerTest: def __init__(self, proxyip): # 本地socket服务 self.ser = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.proxyip = proxyip def run(self): try: # 本地服务IP和端口 self.ser.bind(('127.0.0.1', 9999)) # 最大连接数 self.ser.listen(5) except error as e: print(\"[-]The local service : \" + str(e)) return \"[-]The local service : \" + str(e) while True: try: # 接收客户端数据 client, addr = self.ser.accept() print('[*]accept %s connect' % (addr,)) data = client.recv(1024) if not data: break print('[*' + localtime + ']: Accept data...') except error as e: print(\"[-]Local receiving client : \" + str(e)) return \"[-]Local receiving client : \" + str(e) while True: # 目标代理服务器，将客户端接收数据转发给代理服务器 mbsocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) iplen = len(self.proxyip) proxyip = self.proxyip[random.randint(0, iplen - 1)] print(\"[!]Now proxy ip:\" + str(proxyip)) prip = proxyip[0] prpo = proxyip[1 try: mbsocket.settimeout(3) mbsocket.connect((prip, prpo)) except: print(\"[-]RE_Connect...\") continue break # except : # print(\"[-]Connect failed,change proxy ip now...\") # pass try: mbsocket.send(data) except error as e: print(\"[-]Sent to the proxy server : \" + str(e)) return \"[-]Sent to the proxy server : \" + str(e) while True: try: # 从代理服务器接收数据，然后转发回客户端 data_1 = mbsocket.recv(1024) if not data_1: break print('[*' + localtime + ']: Send data...') client.send(data_1) except socket.timeout as e: print(proxyip) print(\"[-]Back to the client : \" + str(e)) continue # 关闭连接 client.close() mbsocket.close()def Loadips(): print(\"[*]Loading proxy ips..\") ip_list = [] ip = ['ip', 'port'] with open(\"ips.txt\") as ips: lines = ips.readlines() for line in lines: ip[0], ip[1] = line.strip().split(\":\") ip[1] = eval(ip[1]) nip = tuple(ip) ip_list.append(nip) return ip_listdef main(): print('''*Atuhor : V@1n3R.*Blog :http://www.Lz1y.cn*date: 2017.7.17*http://www.Lz1y.cn/wordpress/?p=643 __ __ _ _____ ____ \\ \\ / /_ _/ |_ __ |___ /| _ \\ \\ \\ / / _` | | '_ \\ |_ \\| |_) | \\ V / (_| | | | | |___) | _ &lt; _ \\_/ \\__,_|_|_| |_|____/|_| \\_(_) ''') ip_list = Loadips() # ip_list = [('118.89.148.92',8088)] # ip_list = tuple(ip_list) try: pst = ProxyServerTest(ip_list) # 多线程 t = threading.Thread(target=pst.run, name='LoopThread') print('[*]Waiting for connection...') # 关闭多线程 t.start() t.join() except Exception as e: print(\"[-]main : \" + str(e)) return \"[-]main : \" + str(e)if __name__ == '__main__': main() SqlMap使用代理池 sqlmap加上代理 “–proxy=http://127.0.0.1:9999” 即可使用 使用之前建议先检测一下代理的有效性：http://h.jiguangdaili.com/check/","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Sqlmap","slug":"Sqlmap","permalink":"http://yoursite.com/tags/Sqlmap/"}]},{"title":"SqlMap总结","slug":"SqlMap总结","date":"2020-06-22T03:29:58.000Z","updated":"2020-06-22T05:41:42.962Z","comments":true,"path":"2020/06/22/SqlMap总结/","link":"","permalink":"http://yoursite.com/2020/06/22/SqlMap%E6%80%BB%E7%BB%93/","excerpt":"","text":"SqlMap测试基本流程 sqlmap -u “url” sqlmap -u URL –dbs sqlmap -u URL -D database –tables sqlmap -u URL -D database -T tablename –columns sqlmap -u URL -D database -T tablename -C columnsname –dump SqlMap常用命令 1234567891011121314151617181920212223--is-dba 当前用户权限（是否为root权限，mssql下最高权限为sa）-–batch 默认选项运行--dbs 所有数据库--current-db 网站当前数据库--users 所有数据库用户--current-user 当前数据库用户--random-agent 构造随机user-agent–dbms 指定后端数据库,给定后端数据库的类型可以减少减少无关的测试用例--proxy http:&#x2F;&#x2F;local:8080 –threads 10 (可以自定义线程加速) 代理--time-sec&#x3D;TIMESEC DBMS响应的延迟时间（默认为5秒--threads&#x3D; 使用多少线程–fresh-queries fresh-queries会忽略之前的查询结果,进行重新请求操作–flush-session flush-session会清空当前URL相关的session–level 设置检测的方方面面和测试用例 - 默认是1,会尝试POST和GET - 2:Cookie也会加入检测 - 3:User-Agent和Referer也会检测, 更大的值会增加用例量-–technique 指定sqlmap使用的检测技术 B:Boolean-based-blind （布尔型注入） U:Union query-based （联合注入） E:Error-based （报错型注入) S:Starked queries （通过sqlmap读取文件系统、操作系统、注册表必须 使用该参数，可多语句查询注入） T:Time-based blind （基于时间延迟注入） MYSQL新特性secure_file_priv对读写文件的影响 secure-file-priv是在Mysql5.7版本后引入的新特性，secure-file-priv参数是用来限制导入导出传到哪个指定目录 当配置文件内没有secure-file-priv参数，表示限制mysqld 不允许导入|导出 当secure_file_priv的值没有具体值时，表示不对mysqld 的导入|导出做限制 当secure_file_priv的值为/tmp/ ，表示限制mysqld 的导入|导出只能发生在/tmp/目录下 解决方法： windows下：修改my.ini 在[mysqld]内加入secure_file_priv = linux下：修改my.cnf 在[mysqld]内加入secure_file_priv = 之后需重启Mysql SqlMap技巧 抓包注入 从bp抓包文件中检测 1sqlmap.py -r &quot;路径&quot; 指定检测参数 -p 参数名 参数后面加上*d 伪静态注入 1.&#x2F;sqlmap.py -u “http:&#x2F;&#x2F;sfl.fzu.edu.cn&#x2F;index.php&#x2F;Index&#x2F;view&#x2F;id&#x2F;40*.html&quot; 需要登陆的注入 利用cookie参数注入，也可以使用抓包注入： 1sqlmap.py -u &quot;http:&#x2F;&#x2F;xxxxxx&#x2F;sqli&#x2F;?id&#x3D;1&amp; Submit&#x3D;Submit&quot; --cookie&#x3D;&quot;PHPSESSID&#x3D;q3bm4gupu58dqptm0lve1o12u4; security&#x3D;low&quot; 交互式shell 写文件的两个前提： 获取网站的绝对路径 拥有足够的权限dba/root 首先判断当前是否为dba权限 开始写入shell 1sqlmap.py -r &quot;路径&quot; --os-shell 选择shell脚本类型，接着输入路径，写入成功就进入一个交互式的shell命令行，还会返回一个上传文件的路径，也就是写入了2个shell，一个用来执行命令，另一个用来上传，其中上传shell的文件名为tmpugppx.php，出现admin admin这样的文字，这是sqlmap用来确认是否成功写进shell的标志 文件读写 读文件需要知道路径 1sqlmap.py -u &quot;http:&#x2F;&#x2F;xxxxxx&#x2F;sqli&#x2F;?id&#x3D;1&amp;Submit&#x3D;Submit&quot; --cookie&#x3D;&quot;PHPSESSID&#x3D;q3bm4gupu58dqptm0lve1o12u4; security&#x3D;low&quot; --file-read&#x3D;&#x2F;opt&#x2F;lampp&#x2F;htdocs&#x2F;php.ini 写文件 1sqlmap.py -u &quot;http:&#x2F;&#x2F;xxxxxx&#x2F;sqli&#x2F;?id&#x3D;1&amp;Submit&#x3D;Submit&quot; --cookie&#x3D;&quot;PHPSESSID&#x3D;q3bm4gupu58dqptm0lve1o12u4; security&#x3D;low&quot; --file-write C:\\1.txt --file-dest &#x2F;opt&#x2F;lampp&#x2F;htdocs&#x2F;vulnerabilities&#x2F;exec&#x2F;1.txt 表示将本地C:\\\\1.txt 写入到服务器端/opt/lampp/htdocs/vulnerabilities/exec/1.txt 辅助手工注入 两种方式，一种是每执行一次都会使用手工的语句注入一遍，效率比较低，第二种类似于平常命令行执行sql语句 12sqlmap.py -r &quot;路径&quot; --sql-query &quot;sql语句&quot;sqlmap.py -r &quot;路径&quot; --sql-shell SqlMap检测参数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465--current-user 检索当前用户--current-db 检索当前数据库-is-dba 当前用户权限（是否为root权限）-dbs 所有数据库--users 列出用户列表--passwords 列出用户密码的hash值--os-shell 提示为交互式操作系统shell--os-pwn 提示为OOB外壳，Meterpreter或VNC--batch 永远不要要求用户输入，使用默认行为--sql-shell 提示输入交互式sqlmap shell请求: 这些选项可用于指定如何连接到目标URL --data&#x3D;DATA 数据字符串通过POST发送 --cookie&#x3D;COOKIE HTTP Cookie的值 --random-agent 随机选择 HTTP User-Agent 头的值 --proxy&#x3D;PROXY 使用代理去连接目标URL --tor 使用匿名网络 --check-tor 检查Tor是否正确使用File system access（访问文件系统）：这些选项可以被用来访问后端数据库管理系统的底层文件系统。 –file-read&#x3D;RFILE 从后端的数据库管理系统文件系统读取文件 –file-write&#x3D;WFILE 编辑后端的数据库管理系统文件系统上的本地文件 –file-dest&#x3D;DFILE 后端的数据库管理系统写入文件的绝对路径Optimization（优化）：这些选项可用于优化SqlMap的性能。 -o 开启所有优化开关 –predict-output 预测常见的查询输出 –keep-alive 使用持久的HTTP（S）连接 –null-connection 从没有实际的HTTP响应体中检索页面长度 –threads&#x3D;THREADS 最大的HTTP（S）请求并发量（默认为1）Injection（注入）：这些选项可以用来指定测试哪些参数， 提供自定义的注入payloads和可选篡改脚本。 -p TESTPARAMETER 可测试的参数（S） –dbms&#x3D;DBMS 强制后端的DBMS为此值 –os&#x3D;OS 强制后端的DBMS操作系统为这个值 –prefix&#x3D;PREFIX 注入payload字符串前缀 –suffix&#x3D;SUFFIX 注入payload字符串后缀 –tamper&#x3D;TAMPER 使用给定的脚本（S）篡改注入数据Detection（检测）：这些选项可以用来指定在SQL盲注时如何解析和比较HTTP响应页面的内容。 –level&#x3D;LEVEL 执行测试的等级（1-5，默认为1） –risk&#x3D;RISK 执行测试的风险（0-3，默认为1） –string&#x3D;STRING 查询时有效时在页面匹配字符串 –regexp&#x3D;REGEXP 查询时有效时在页面匹配正则表达式 –text-only 仅基于在文本内容比较网页Techniques（技巧）：这些选项可用于调整具体的SQL注入测试。 –technique&#x3D;TECH SQL注入技术测试（默认BEUST） –time-sec&#x3D;TIMESEC DBMS响应的延迟时间（默认为5秒） –union-cols&#x3D;UCOLS 定列范围用于测试UNION查询注入 –union-char&#x3D;UCHAR 用于暴力猜解列数的字符Fingerprint（指纹）： -f, –fingerprint 执行检查广泛的DBMS版本指纹Brute force（蛮力）：这些选项可以被用来运行蛮力检查。 –common-tables 检查存在共同表 –common-columns 检查存在共同列","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Sqlmap","slug":"Sqlmap","permalink":"http://yoursite.com/tags/Sqlmap/"}]},{"title":"BurpSuite——Intruder四种模式详解","slug":"BurpSuite——Intruder四种模式详解","date":"2020-06-17T14:57:52.000Z","updated":"2020-06-17T14:59:23.398Z","comments":true,"path":"2020/06/17/BurpSuite——Intruder四种模式详解/","link":"","permalink":"http://yoursite.com/2020/06/17/BurpSuite%E2%80%94%E2%80%94Intruder%E5%9B%9B%E7%A7%8D%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"一、Sniper（狙击手） Sniper模式只能使用一组 payload 集合，一次只使用一个 payload 位置；假如标记了两个位置 “A” 和 “B” ，payload 集合内有“1”和“2”两个值，那么它攻击会形成以下组合： 攻击序列 位置A 位置B 1 1 不替换 2 2 不替换 3 不替换 1 4 不替换 2 适用场景：竞争条件测试（选择Null payloads），密码、验证码暴力破解，重放攻击等场景 二、Battering ram（攻城锤） 同样只能使用一组 payload 集合，不同的地方在于每次攻击都是替换所有payload标记位置；如果添加了两个参数的话，就一起进行爆破，两个参数爆破时候的值肯定就是一样的了： 攻击序列 位置A 位置B 1 1 1 2 2 2 适用场景：暴力破解 三、Pitchfork（草叉） 草叉模式允许使用多组payload组合，如果只添加了一个参数的话，会报错；在每个标记位置上遍历各自对应的payload组合，假设有两个位置“A”和“B”，payload组合1的值为“1”和“2”，payload组合2的值为“3”和“4”，那么它攻击会形成以下组合： 攻击序列 位置A 位置B 1 1 3 2 2 4 注：如果两个payload行数不一致的话，取最小值进行测试。所以爆破的次数取两个中最小的为准。 适用场景：恶意注册、撞裤 四、Cluster bomb（集束炸弹） 集束炸弹也允许使用多组payload组合，跟草叉模式不同的地方在于，集束炸弹模式会对payload组进行笛卡尔积，那么它攻击会形成以下组合： 攻击序列 位置A 位置B 1 1 3 2 1 4 1 2 3 2 2 4 适用场景：账号、密码暴力破解","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"BurpSuite","slug":"BurpSuite","permalink":"http://yoursite.com/tags/BurpSuite/"}]},{"title":"JS逆向系列一","slug":"JS逆向一","date":"2020-06-17T10:16:58.000Z","updated":"2020-06-17T10:30:14.032Z","comments":true,"path":"2020/06/17/JS逆向一/","link":"","permalink":"http://yoursite.com/2020/06/17/JS%E9%80%86%E5%90%91%E4%B8%80/","excerpt":"","text":"谷歌学术镜像 目标网址：https://ac.scmor.com/ 目的是爬取学术镜像的真实地址，在Elements视图下，观察现在访问a标签，发现启用了onclick事件，调用了visit()函数，函数内的内容，猜测就是加密后的真实URL地址。 全局搜索visit,在 https://ac.scmor.com/res/?f=run&amp;v=1590682984 中，找到了visit函数 经过观察，猜测strdecode是解密函数，就在上几行的位置，有个可疑参数autour[b]，猜测是URL地址，在Console中测试一下 经测试，autour是个数组，里面存放了加密后的真实地址，strdecode也的确是解密函数，现在去拉取strdecode函数具体内容 全局搜索，找到了strdecode，经过初步观察，是Base64加密，然后缺啥补啥，将加密函数完整的提取出来 到此，加密函数也有了，现在需要收集全部的URL，于是，之前的autour数组，也拉下来，现在只需要遍历一下就好了，刚好有个run函数就是For循环遍历autour数组，也拿下来 稍微修改下细节，就大功告成，效果图如下： DNS.COM 目标网址：https://www.dns.com/login.html 随便输入帐号密码进行测试，发现有个XHR请求，里面的password，email两个请求参数都做了加密，猜测这就是刚才输入的帐号密码 全局搜索 password,通过在后面加上 : 或者 = 可以缩小范围，排除多余项，找到了password:的位置，现在其实已经很明显是AES加密了，但还是测试一下吧 打断点，重新登陆，果然进入debugger状态了。 然后在console中测试下aes()函数以及它的参数到底是什么，经验证，发现aes()正是一个加密函数，加密后的内容和一开始看到的相吻合 现在查看aes函数具体的内容，发现了又有k和iv，并且有个CryptoJS对象 全局搜索CryptoJS，发现了crypto-js.js文件，明显这是CryptoJS加密库 并且发现还用了$(selector).action()的jQuery语法，所以还需要载入jQuery库 从网上下载单独的CryptoJS库文件引入，从 网页中获取jQuery链接，并载入 jQuery，然后将aes函数也拉下来 效果图如下： 贝贝网 目标网址：https://m.beibei.com/login/login.html （需手机端） 输入帐号密码及验证码进行测试，发现一个XHR请求，类型为POST，提交的表单数据中的用户名密码都为明文，但问题在于请求参数中的_abr_一直在变化，猜测它为加密参数 全局搜索_abr_无果，只能打请求断点，成功断住 但是发现断点的位置没有我们要的内容，于是在call Stack中往下找调用栈，call Stack内的方法调用栈的规则是从上到下由最新调用处依次往下排列。在e.ajax中发现了包含有_abr_的内容，但是这里是要发送出去了，没有它的产生过程，于是继续往下找，终于找到了_abr_= 记录_abr_的值为：“013e01885f35c08258b6ce21d500874ed5bb3143a05ed4b7b1” 发现_abr_其实是由m(e.type, e.uri.pathname, e.query, e.form)函数生成，于是为了了解它的生成过程，在函数前打上断点，重新发送登陆请求 单步跟踪，发现了关键函数MD5 继续单步跟踪，又发现了一个关键函数HMAC 网上查找资料了解这个加密算法，发现HMAC算法，需要一个信息摘要算法以及一个密钥，在下方又找到关键函数HmacSHA1，于是推测使用了SHA-1算法 经过长时间的单步跟踪，总算来到了一开始的函数返回值部分 现在，我们开始分析，HMAC算法可以使用Python第三方库实现，先尝试一下。加密内容有了，密钥也有了（加密目标值可以用JSON.stringify()提取） 加密目标值：“01\\nPOST\\nb7da15fd7cdc2b8c73958ee82e7424aa\\n/mroute.html?method=beibei.user.token.get\\n1591002077” 密钥：“ytU7vwqIx2UXQNsi” Python测试效果如下 但是发现，与_abr的值相较，少了一些内容，回过头观察，发现_abr的值由a+m+h组成，a经测试是固定值01，m就是经过HMAC加密后的值，h会变动且暂时还不清楚 对h进行分析，发现是由s的值使用toString(16)函数变化而来，而s则是时间戳(new Date)变化而来 提取出h的算法，测试了一下，成功 接下来，只剩下需要加密的值，它如何产生的，观察发现由a + &quot;\\n&quot; + e + &quot;\\n&quot; + f + &quot;\\n&quot; + p + &quot;\\n&quot; + s组成，a、s都清楚了，e发现是POST，p是路径/mroute.html?method=beibei.h5.login，这两个也是固定值，只剩下f是MD5加密后的值，逆向f的产生过程，发现是由&quot;用户名+路径+登陆id&quot;产生而来，如：username=12341234123&amp;scene=h5_login&amp;rams_device_id=2654748010 所以现在只需要将这个值MD5加密后传入即可，同样也能用Python实现 最终完成的效果","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://yoursite.com/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"JS逆向系列","slug":"JS逆向系列","permalink":"http://yoursite.com/tags/JS%E9%80%86%E5%90%91%E7%B3%BB%E5%88%97/"}]},{"title":"JS逆向系列之谷歌翻译","slug":"JS逆向之谷歌翻译","date":"2020-06-17T10:16:58.000Z","updated":"2020-06-17T10:25:36.955Z","comments":true,"path":"2020/06/17/JS逆向之谷歌翻译/","link":"","permalink":"http://yoursite.com/2020/06/17/JS%E9%80%86%E5%90%91%E4%B9%8B%E8%B0%B7%E6%AD%8C%E7%BF%BB%E8%AF%91/","excerpt":"","text":"一、逆向谷歌翻译 分析过程 首次分析 首先找到谷歌翻译的Ajax请求接口 以get方式发送的Ajax请求，多次尝试，发现请求参数中，tk和q，是不断变化的，其中q是待翻译的内容，tk是根据q进行js加密算法生成的，所以我们要分析tk的产生。 通过断点逆向tk的加密算法 加密算法应该在translate_m_zh-CN.js文件里 打个断点，请求翻译接口的URL时停止，发现在send(a)中停止了，根据Call Stack的调用关系，一步步分析，最上面的就是send函数 依次往下点击每一个调用的函数，当到了QE函数的时候，发现了tk参数来自b，b又明显来自c 于是我们顺藤摸瓜，发现c是由PE(d)产生的，PE又是来自pu(a)函数，我们跳转到pu函数的位置，似乎已经有了答案 分析生成tk的JS代码 如下是我们刚获取的JS代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var mu = function(a) &#123; return function() &#123; return a &#125;&#125; , nu = function(a, b) &#123; for (var c = 0; c &lt; b.length - 2; c += 3) &#123; var d = b.charAt(c + 2); d = \"a\" &lt;= d ? d.charCodeAt(0) - 87 : Number(d); d = \"+\" == b.charAt(c + 1) ? a &gt;&gt;&gt; d : a &lt;&lt; d; a = \"+\" == b.charAt(c) ? a + d &amp; 4294967295 : a ^ d &#125; return a&#125; , ou = null , pu = function(a) &#123; if (null !== ou) var b = ou; else &#123; b = mu(String.fromCharCode(84)); var c = mu(String.fromCharCode(75)); b = [b(), b()]; b[1] = c(); b = (ou = window[b.join(c())] || \"\") || \"\" &#125; var d = mu(String.fromCharCode(116)); c = mu(String.fromCharCode(107)); d = [d(), d()]; d[1] = c(); c = \"&amp;\" + d.join(\"\") + \"=\"; d = b.split(\".\"); b = Number(d[0]) || 0; for (var e = [], f = 0, g = 0; g &lt; a.length; g++) &#123; var h = a.charCodeAt(g); 128 &gt; h ? e[f++] = h : (2048 &gt; h ? e[f++] = h &gt;&gt; 6 | 192 : (55296 == (h &amp; 64512) &amp;&amp; g + 1 &lt; a.length &amp;&amp; 56320 == (a.charCodeAt(g + 1) &amp; 64512) ? (h = 65536 + ((h &amp; 1023) &lt;&lt; 10) + (a.charCodeAt(++g) &amp; 1023), e[f++] = h &gt;&gt; 18 | 240, e[f++] = h &gt;&gt; 12 &amp; 63 | 128) : e[f++] = h &gt;&gt; 12 | 224, e[f++] = h &gt;&gt; 6 &amp; 63 | 128), e[f++] = h &amp; 63 | 128) &#125; a = b; for (f = 0; f &lt; e.length; f++) a += e[f], a = nu(a, \"+-a^+6\"); a = nu(a, \"+-3^+b+-f\"); a ^= Number(d[1]) || 0; 0 &gt; a &amp;&amp; (a = (a &amp; 2147483647) + 2147483648); a %= 1E6; return c + (a.toString() + \".\" + (a ^ b))&#125;; 发现做了很多不必要的操作、甚至多此一举，目的是用于混淆 如： 12345var mu &#x3D; function(a) &#123; return function() &#123; return a &#125;&#125; 还用了.fromCharCode()函数，把数字转换为字母，明显多此一举的操作。但是，通过分析，发现tk生成需要另一样东西，就是tkk这个参数，来源于网页源代码上，寻找一番，还是发现了，多次尝试，发现这个值是固定的 具体实现 说明：js文件做了精炼，把不必要的值去掉了，实行的效果是英译中，不同语言的翻译修改请求的参数即可 Python脚本 1234567891011121314151617181920212223242526import requestsimport jsonimport execjsdef get_tk(q): with open('google_tk.js', 'r', encoding='utf-8') as f: js = f.read() j = execjs.compile(js) tk = j.call('pu', q) return tkdef translate_google(): q = input(\"请输入你要翻译的内容：\") headers = &#123; \"user-agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.61 Safari/537.36\", \"referer\": \"https://translate.google.cn/\" &#125; url = \"https://translate.google.cn/translate_a/single?client=webapp&amp;sl=en&amp;tl=zh-CN&amp;hl=zh-CN&amp;dt=at&amp;dt=bd&amp;dt=ex&amp;dt=ld&amp;dt=md&amp;dt=qca&amp;dt=rw&amp;dt=rm&amp;dt=sos&amp;dt=ss&amp;dt=t&amp;otf=2&amp;ssel=0&amp;tsel=0&amp;kc=3&amp;tk=\" + get_tk( q) + \"&amp;q=\" + q res = requests.get(url, headers=headers) data = res.content.decode() json_data = json.loads(data) print(json_data[0][0][0])if __name__ == \"__main__\": translate_google() tk.js 1234567891011121314151617181920212223242526272829303132//tkk = '441865.2154418832';var nu = function (a, b) &#123; for (var c = 0; c &lt; b.length - 2; c += 3) &#123; var d = b.charAt(c + 2); d = \"a\" &lt;= d ? d.charCodeAt(0) - 87 : Number(d); d = \"+\" == b.charAt(c + 1) ? a &gt;&gt;&gt; d : a &lt;&lt; d; a = \"+\" == b.charAt(c) ? a + d &amp; 4294967295 : a ^ d &#125; return a&#125;,pu = function (a) &#123; tkk='441865.2154418832'; var d = tkk.split(\".\"); var b = Number(d[0]); for (var e = [], f = 0, g = 0; g &lt; a.length; g++) &#123; var h = a.charCodeAt(g); 128 &gt; h ? e[f++] = h : (2048 &gt; h ? e[f++] = h &gt;&gt; 6 | 192 : (55296 == (h &amp; 64512) &amp;&amp; g + 1 &lt; a.length &amp;&amp; 56320 == (a.charCodeAt(g + 1) &amp; 64512) ? (h = 65536 + ((h &amp; 1023) &lt;&lt; 10) + (a.charCodeAt(++g) &amp; 1023), e[f++] = h &gt;&gt; 18 | 240, e[f++] = h &gt;&gt; 12 &amp; 63 | 128) : e[f++] = h &gt;&gt; 12 | 224, e[f++] = h &gt;&gt; 6 &amp; 63 | 128), e[f++] = h &amp; 63 | 128) &#125; a = b; for (f = 0; f &lt; e.length; f++) a += e[f], a = nu(a, \"+-a^+6\"); a = nu(a, \"+-3^+b+-f\"); a ^= Number(d[1]) || 0; 0 &gt; a &amp;&amp; (a = (a &amp; 2147483647) + 2147483648); a %= 1E6; return (a.toString() + \".\" + (a ^ b))&#125;; 运行效果 二、总结常见算法的加密原理 散列(hash)函数算法：MD5、SHA 对称加密算法：DES、3DES、AES 非对称性加密算法：RSA、DSA、ECC 散列(hash)函数算法 简介 Hash也称散列、哈希，对应的英文都是Hash。基本原理就是把任意长度的输入，通过Hash算法变成固定长度的输出。这个映射的规则就是对应的Hash算法，而原始数据映射后的二进制串就是哈希值。活动开发中经常使用的MD5和SHA都是历史悠久的Hash算法。 1echo md5(&quot;这是一个测试文案&quot;);&#x2F;&#x2F; 输出结果：2124968af757ed51e71e6abeac04f98d 特点 一、不可逆，与原视数据没有对应关系 二、输入数据的微小变化会得到完全不同的hash值，相同的数据会得到相同的值 三、hash算法冲突概率比较小，但是根据抽屉原理，一定会存在不同的输入被映射成相同输出的情况 对称加密算法 简介 秘钥：加密解密使用同一个密钥、数据的机密性双向保证、加密效率高、适合加密于大数据大文件、加密强度不高(相对于非对称加密) 非对称性加密算法 简介 秘钥：加密解密使用的不同秘钥、有两个密钥、需要使用密钥生成算法生成两个秘钥、数据的机密性只能单向加密、如果想解决这个问题、双向都需要各自有一对秘钥、加密效率低、加密强度高","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://yoursite.com/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"JS逆向系列","slug":"JS逆向系列","permalink":"http://yoursite.com/tags/JS%E9%80%86%E5%90%91%E7%B3%BB%E5%88%97/"}]},{"title":"VulnHub渗透之DC-1","slug":"VulnHub渗透之DC-1","date":"2020-05-25T04:57:51.000Z","updated":"2020-05-25T04:58:49.509Z","comments":true,"path":"2020/05/25/VulnHub渗透之DC-1/","link":"","permalink":"http://yoursite.com/2020/05/25/VulnHub%E6%B8%97%E9%80%8F%E4%B9%8BDC-1/","excerpt":"","text":"0×00 说明 kali与目标处于同一网段下 攻击机：Kali(VMware ) IP:192.168.1.31 特别说明：每个靶机作者都对靶机做了详细的描述以及攻击目标，比如DC1就需要找到5个flag，最终目标是在root的主目录中找到并读取该标志！ 通过每个flag所获得知识点 1、msf的熟练使用以及搜索可利用漏洞（Drupal）； 2、留意目标网站的配置文件（慢慢查看别错过重要信息）； 3、数据库管理员提权（更新管理员密码或者添加一个新用户）； 4、suid提权的命令（nmap、vim、find、bash、more、less、nano、cp）。 0×01 信息收集 探测目标IP namp -sP 192.168.1.0/24 arp-scan -l //扫描当前网段下的IP Cadmus Computer Systems 表示Virtualbox虚拟机 分析得出目标IP为192.168.1.30 靶机：DC-1(Virtualbox) IP:192.168.1.30 扫描端口 nmap -sV -p- 192.168.1.30 //扫描全端口 -sV 用来扫描目标主机和端口上运行的软件的版本 -p- 扫描0-65535全部端口 80端口开放，访问一下 Wappalyzer进行网站指纹识别，查看到是Drupal 7 查看一下robots.txt文件已经目录扫描(省略)。。发现没有可利用的地方 0×02metasploit 直接上metasploit 12root@sf:~# msfconsolemsf &gt; search Drupal 选择4，drupalgeddon2的exp，设置下rhost，直接exploit，成功 接下来使用msf自带的shell 发现flag1 查看当前路径下的文件，发现flag1.txt文件，查看一下，发现提示CMS配置文件有猫腻 发现flag2 网上搜索得知，Drupal 7的默认配置文件为sites/default/settings.php，查看发现flag2，还有数据库连接信息 0×003 弯路 尝试连接数据库，结果连接失败，应该是权限不足 爆破flag4用户密码 于是去查看/etc/passwd文件，发现flag4用户 使用hydra尝试爆破flag4用户的密码，hydra -l flag4 -P /usr/share/john/password.lst ssh://192.168.1.30 成功爆破flag4的密码，为 orange ，接下来ssh登录flag4用户，查看当前路径下有flag4.txt，得到新的提示——root目录里有个flag 0×04 连接数据库 然后我们连接数据库，这次成功 顺藤摸瓜，仔细查找数据库 查看user表，发现admin用户 查看role表 查看role_permission表 查看node表 发现flag3 发现flag3，得知uid为1的用户是不受Drupal权限管制的，具有最高权限，uid 1用户也就是admin， 0×05 两个思路 一、重置管理员密码 使用Drupal对数据库的加密方法，加密脚本位置在网站根目录下的script下(msf shell)，使用脚本生成加密密文，然后登陆数据库修改admin的密码 修改密码为123456 成功登陆 二、添加一个管理员权限的用户 先查看一下靶机的版本，7.24 msf搜索Druapl 7.24对应可利用的脚本，发现一个符合 运行脚本，进行利用 增加了一个用户user，密码为123456，尝试登陆网站，发现登陆成功 发现flag3 从网站上找到了flag3的界面，得到提示Special PERMS will help FIND the passwd - but you'll need to -exec that command to work out how to get what's in the shadow.，重点在（FIND the passwd、need to -exec that command、in the shadow） 根据线索，我们又找到了flag4以及它的目录，再根据flag4的提示，（用相同的方法在root目录下）找到最终flag 0×06 提权 于是，想到suid提权，查询具有root权限的命令，以下均可查询： find / -user root -perm -4000 -print 2&gt;/dev/null find / -perm -u=s -type f 2&gt;/dev/null find / -user root -perm -4000 -exec ls -ldb { } 注： -type f即文件，-perm -u=s 即user权限位为suid 发现find命令本身就是root权限 于是就用find提权，find ./ aaa -exec '/bin/sh' \\\\; ，或者新建一个文件，验证一下，已经是root了 最终flag 接着找到根目录下的root目录，里面就是最终的flag 0×07 总结 DC-1找到最终的flag并不难，难在找齐五个flag，第一次实验，很生疏，存在很多问题： metasploit 熟练度不足，且exploit模块成功后的shell不是交互性，DC-1安装了python环境，可以通过pty.spawn()获得交互性shell exploitdb熟练度也不足 Linux熟练度不足，find命令，有待学习 suid提权的命令（nmap、vim、find、bash、more、less、nano、cp），有待学习","categories":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/categories/%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"VulnHub","slug":"VulnHub","permalink":"http://yoursite.com/tags/VulnHub/"}]}],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"},{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/categories/%E6%B8%97%E9%80%8F/"},{"name":"JS逆向","slug":"JS逆向","permalink":"http://yoursite.com/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"NMAP","slug":"NMAP","permalink":"http://yoursite.com/tags/NMAP/"},{"name":"CDN","slug":"CDN","permalink":"http://yoursite.com/tags/CDN/"},{"name":"Sqlmap","slug":"Sqlmap","permalink":"http://yoursite.com/tags/Sqlmap/"},{"name":"BurpSuite","slug":"BurpSuite","permalink":"http://yoursite.com/tags/BurpSuite/"},{"name":"JS逆向系列","slug":"JS逆向系列","permalink":"http://yoursite.com/tags/JS%E9%80%86%E5%90%91%E7%B3%BB%E5%88%97/"},{"name":"VulnHub","slug":"VulnHub","permalink":"http://yoursite.com/tags/VulnHub/"}]}